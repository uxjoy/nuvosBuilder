"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = default_1;
const devkit_1 = require("@nx/devkit");
const versions_1 = require("../../utils/versions");
const transform_esm_1 = require("./lib/transform-esm");
const transform_cjs_1 = require("./lib/transform-cjs");
async function default_1(tree, options) {
    const projects = (0, devkit_1.getProjects)(tree);
    if (!projects.has(options.project)) {
        throw new Error(`Could not find project '${options.project}'. Ensure you have specified the project you'd like to convert correctly.`);
    }
    const project = projects.get(options.project);
    const webpackConfigsToConvert = [];
    for (const [targetName, target] of Object.entries(project.targets)) {
        if (target.executor === '@nx/webpack:webpack') {
            target.executor = '@nx/rspack:rspack';
            if (!target.options.target) {
                target.options.target = 'web';
            }
            const convertWebpackConfigOption = (options) => {
                if (!options.webpackConfig) {
                    return;
                }
                const rspackConfigPath = options.webpackConfig.replace(/webpack(?!.*webpack)/, 'rspack');
                webpackConfigsToConvert.push([options.webpackConfig, rspackConfigPath]);
                options.rspackConfig = rspackConfigPath;
                delete options.webpackConfig;
            };
            if (target.options.webpackConfig) {
                convertWebpackConfigOption(target.options);
            }
            if (target.configurations) {
                for (const [configurationName, configuration] of Object.entries(target.configurations)) {
                    convertWebpackConfigOption(configuration);
                }
            }
        }
        else if (target.executor === '@nx/webpack:dev-server') {
            target.executor = '@nx/rspack:dev-server';
        }
        else if (target.executor === '@nx/webpack:ssr-dev-server') {
            target.executor = '@nx/rspack:dev-server';
        }
        else if (target.executor === '@nx/react:module-federation-dev-server') {
            target.executor = '@nx/rspack:module-federation-dev-server';
        }
        else if (target.executor === '@nx/react:module-federation-ssr-dev-server') {
            target.executor = '@nx/rspack:module-federation-ssr-dev-server';
        }
        else if (target.executor === '@nx/react:module-federation-static-server') {
            target.executor = '@nx/rspack:module-federation-static-server';
        }
    }
    for (const [webpackConfigPath, rspackConfigPath] of webpackConfigsToConvert) {
        tree.rename(webpackConfigPath, rspackConfigPath);
        transformConfigFile(tree, rspackConfigPath);
    }
    (0, devkit_1.updateProjectConfiguration)(tree, options.project, project);
    const nxJson = (0, devkit_1.readNxJson)(tree);
    if (nxJson.plugins !== undefined && nxJson.plugins.length > 0) {
        const nonRspackPlugins = nxJson.plugins.filter((plugin) => (typeof plugin !== 'string' && plugin.plugin !== '@nx/rspack/plugin') ||
            (typeof plugin === 'string' && plugin !== '@nx/rspack/plugin'));
        let rspackPlugins = nxJson.plugins.filter((plugin) => (typeof plugin !== 'string' && plugin.plugin === '@nx/rspack/plugin') ||
            (typeof plugin === 'string' && plugin === '@nx/rspack/plugin'));
        if (rspackPlugins.length === 0) {
            rspackPlugins = rspackPlugins.map((plugin) => {
                if (typeof plugin === 'string') {
                    return {
                        plugin: plugin,
                        exclude: [`${project.root}/*`],
                    };
                }
                return {
                    ...plugin,
                    exclude: [...(plugin.exclude ?? []), `${project.root}/*`],
                };
            });
            nxJson.plugins = [...nonRspackPlugins, ...rspackPlugins];
            (0, devkit_1.updateNxJson)(tree, nxJson);
        }
    }
    const installTask = (0, devkit_1.addDependenciesToPackageJson)(tree, {}, {
        '@rspack/core': versions_1.rspackCoreVersion,
        '@rspack/dev-server': versions_1.rspackDevServerVersion,
    });
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return installTask;
}
function transformConfigFile(tree, configPath) {
    (0, transform_esm_1.transformEsmConfigFile)(tree, configPath);
    (0, transform_cjs_1.transformCjsConfigFile)(tree, configPath);
    cleanupEmptyImports(tree, configPath);
    replaceOfRequireOfLocalWebpackConfig(tree, configPath);
}
function replaceOfRequireOfLocalWebpackConfig(tree, configPath) {
    const requireOfLocalWebpackConfig = /(?<=require\s*\(\s*['"][^'"]*)(webpack)(?!.*webpack)(?=[^'"]*['"]\s*\))/g;
    const configContents = tree.read(configPath, 'utf-8');
    const newContents = configContents.replace(requireOfLocalWebpackConfig, 'rspack');
    tree.write(configPath, newContents);
}
function cleanupEmptyImports(tree, configPath) {
    const emptyImportRegex = /import\s*\{\s*\}\s*from\s*['"][^'"]+['"];/g;
    const emptyConstRequires = /(const|let)\s*\{\s*\}\s*=\s*require\s*\(\s*['"][^'"]+['"]\s*\);/g;
    const configContents = tree.read(configPath, 'utf-8');
    let newContents = configContents.replace(emptyImportRegex, '');
    newContents = newContents.replace(emptyConstRequires, '');
    tree.write(configPath, newContents);
}
