"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = runExecutor;
const devkit_1 = require("@nx/devkit");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
const js_1 = require("@nx/js");
const fs_1 = require("fs");
const create_compiler_1 = require("../../utils/create-compiler");
const mode_utils_1 = require("../../utils/mode-utils");
const normalize_options_1 = require("./lib/normalize-options");
const path_1 = require("path");
async function* runExecutor(options, context) {
    process.env.NODE_ENV ??= options.mode ?? 'production';
    options.target ??= 'web';
    const metadata = context.projectsConfigurations.projects[context.projectName];
    const sourceRoot = metadata.sourceRoot;
    const normalizedOptions = (0, normalize_options_1.normalizeOptions)(options, context.root, metadata.root, sourceRoot);
    if ((0, mode_utils_1.isMode)(process.env.NODE_ENV)) {
        normalizedOptions.mode = process.env.NODE_ENV;
    }
    if (normalizedOptions.typeCheck) {
        await executeTypeCheck(normalizedOptions, context);
    }
    // Mimic --clean from webpack.
    (0, fs_1.rmSync)((0, path_1.join)(context.root, normalizedOptions.outputPath), {
        force: true,
        recursive: true,
    });
    const compiler = await (0, create_compiler_1.createCompiler)(normalizedOptions, context);
    const iterable = (0, async_iterable_1.createAsyncIterable)(async ({ next, done }) => {
        if (options.watch) {
            const watcher = compiler.watch({}, async (err, stats) => {
                if (err) {
                    devkit_1.logger.error(err);
                    next({ success: false });
                    return;
                }
                if (!compiler || !stats) {
                    devkit_1.logger.error(new Error('Compiler or stats not available'));
                    next({ success: false });
                    return;
                }
                const statsOptions = getStatsOptions(compiler);
                const printedStats = stats.toString(statsOptions);
                // Avoid extra empty line when `stats: 'none'`
                if (printedStats) {
                    console.error(printedStats);
                }
                next({
                    success: !stats.hasErrors(),
                    outfile: (0, path_1.resolve)(context.root, normalizedOptions.outputPath, 'main.js'),
                });
            });
            registerCleanupCallback(() => {
                watcher.close(() => {
                    devkit_1.logger.info('Watcher closed');
                });
            });
        }
        else {
            compiler.run(async (err, stats) => {
                compiler.close(() => {
                    if (err) {
                        devkit_1.logger.error(err);
                        next({ success: false });
                        return;
                    }
                    if (!compiler || !stats) {
                        devkit_1.logger.error(new Error('Compiler or stats not available'));
                        next({ success: false });
                        return;
                    }
                    const statsOptions = getStatsOptions(compiler);
                    const printedStats = stats.toString(statsOptions);
                    // Avoid extra empty line when `stats: 'none'`
                    if (printedStats) {
                        console.error(printedStats);
                    }
                    next({
                        success: !stats.hasErrors(),
                        outfile: (0, path_1.resolve)(context.root, normalizedOptions.outputPath, 'main.js'),
                    });
                    done();
                });
            });
        }
    });
    yield* iterable;
}
// copied from packages/esbuild/src/executors/esbuild/esbuild.impl.ts
function registerCleanupCallback(callback) {
    const wrapped = () => {
        callback();
        process.off('SIGINT', wrapped);
        process.off('SIGTERM', wrapped);
        process.off('exit', wrapped);
    };
    process.on('SIGINT', wrapped);
    process.on('SIGTERM', wrapped);
    process.on('exit', wrapped);
}
async function executeTypeCheck(options, context) {
    const projectConfiguration = context.projectGraph.nodes[context.projectName].data;
    const result = await (0, js_1.runTypeCheck)({
        workspaceRoot: (0, path_1.resolve)(projectConfiguration.root),
        tsConfigPath: options.tsConfig,
        mode: 'noEmit',
    });
    await (0, js_1.printDiagnostics)(result.errors, result.warnings);
    if (result.errors.length > 0) {
        throw new Error('Found type errors. See above.');
    }
}
function getStatsOptions(compiler) {
    return (0, create_compiler_1.isMultiCompiler)(compiler)
        ? {
            children: compiler.compilers.map((compiler) => compiler.options ? compiler.options.stats : undefined),
        }
        : compiler.options
            ? compiler.options.stats
            : undefined;
}
