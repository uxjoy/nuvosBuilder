"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NxTsconfigPathsRspackPlugin = void 0;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const devkit_1 = require("@nx/devkit");
const buildable_libs_utils_1 = require("@nx/js/src/utils/buildable-libs-utils");
const rspack_nx_build_coordination_plugin_1 = require("./rspack-nx-build-coordination-plugin");
const fs_1 = require("fs");
class NxTsconfigPathsRspackPlugin {
    constructor(options) {
        this.options = options;
        if (!this.options.tsConfig)
            throw new Error(`Missing "tsConfig" option. Set this option in your Nx rspack plugin.`);
    }
    apply(compiler) {
        // TODO(Colum): Investigate the best way to handle this, currently it is not working and affecting HMR
        // // If we are not building libs from source, we need to remap paths so tsconfig may be updated.
        this.handleBuildLibsFromSource(compiler.options, this.options);
        const pathToTsconfig = !path.isAbsolute(this.options.tsConfig)
            ? path.join(devkit_1.workspaceRoot, this.options.tsConfig)
            : this.options.tsConfig;
        const extensions = new Set([
            ...['.ts', '.tsx', '.mjs', '.js', '.jsx'],
            ...(compiler.options?.resolve?.extensions ?? []),
        ]);
        compiler.options.resolve = {
            ...compiler.options.resolve,
            extensions: [...extensions],
            tsConfig: { configFile: pathToTsconfig },
        };
    }
    cleanupTmpTsConfigFile() {
        if (this.tmpTsConfigPath) {
            try {
                if (this.tmpTsConfigPath) {
                    (0, fs_1.unlinkSync)(this.tmpTsConfigPath);
                }
            }
            catch (e) { }
        }
    }
    handleBuildLibsFromSource(config, options) {
        if (!options.buildLibsFromSource && options.targetName) {
            const remappedTarget = options.targetName === 'serve' ? 'build' : options.targetName;
            const { target, dependencies } = (0, buildable_libs_utils_1.calculateProjectBuildableDependencies)(undefined, options.projectGraph, options.root, options.projectName, remappedTarget, options.configurationName);
            options.tsConfig = (0, buildable_libs_utils_1.createTmpTsConfig)(options.tsConfig, options.root, target.data.root, dependencies, true // There is an issue with Rspack that requires the baseUrl to be set in the generated tsconfig
            );
            this.tmpTsConfigPath = options.tsConfig;
            if (options.targetName === 'serve') {
                const buildableDependencies = dependencies
                    .filter((dependency) => dependency.node.type === 'lib')
                    .map((dependency) => dependency.node.name)
                    .join(',');
                const buildCommand = `nx run-many --target=build --projects=${buildableDependencies}`;
                if (buildableDependencies && buildableDependencies.length > 0) {
                    config.plugins.push(new rspack_nx_build_coordination_plugin_1.RspackNxBuildCoordinationPlugin(buildCommand));
                }
            }
        }
    }
}
exports.NxTsconfigPathsRspackPlugin = NxTsconfigPathsRspackPlugin;
