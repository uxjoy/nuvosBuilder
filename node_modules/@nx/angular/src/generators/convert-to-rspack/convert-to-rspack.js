"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToRspack = convertToRspack;
const devkit_1 = require("@nx/devkit");
const versions_1 = require("../../utils/versions");
const create_config_1 = require("./lib/create-config");
const get_custom_webpack_config_1 = require("./lib/get-custom-webpack-config");
const update_tsconfig_1 = require("./lib/update-tsconfig");
const validate_supported_executor_1 = require("./lib/validate-supported-executor");
const posix_1 = require("path/posix");
const path_1 = require("path");
const executor_options_utils_1 = require("@nx/devkit/src/generators/executor-options-utils");
const enquirer_1 = require("enquirer");
const SUPPORTED_EXECUTORS = [
    '@angular-devkit/build-angular:browser',
    '@angular-devkit/build-angular:dev-server',
    '@angular-devkit/build-angular:server',
    '@nx/angular:webpack-browser',
    '@nx/angular:webpack-server',
    '@nx/angular:dev-server',
    '@nx/angular:module-federation-dev-server',
];
const RENAMED_OPTIONS = {
    main: 'browser',
    ngswConfigPath: 'serviceWorker',
};
const DEFAULT_PORT = 4200;
const REMOVED_OPTIONS = [
    'buildOptimizer',
    'buildTarget',
    'browserTarget',
    'publicHost',
];
function normalizeFromProjectRoot(tree, path, projectRoot) {
    if (projectRoot === '.') {
        if (!path.startsWith('./')) {
            return `./${path}`;
        }
        else {
            return path;
        }
    }
    else if (path.startsWith(projectRoot)) {
        return path.replace(projectRoot, '.');
    }
    else if (!path.startsWith('./')) {
        if (tree.exists(path)) {
            const pathWithWorkspaceRoot = (0, devkit_1.joinPathFragments)(devkit_1.workspaceRoot, path);
            const projectRootWithWorkspaceRoot = (0, devkit_1.joinPathFragments)(devkit_1.workspaceRoot, projectRoot);
            return (0, path_1.relative)(projectRootWithWorkspaceRoot, pathWithWorkspaceRoot);
        }
        return `./${path}`;
    }
    return path;
}
const defaultNormalizer = (tree, path, root) => normalizeFromProjectRoot(tree, path, root);
const PATH_NORMALIZER = {
    index: (tree, path, root) => {
        if (typeof path === 'string') {
            return normalizeFromProjectRoot(tree, path, root);
        }
        return {
            input: normalizeFromProjectRoot(tree, path.input, root),
            output: path.output ?? 'index.html',
        };
    },
    indexHtmlTransformer: defaultNormalizer,
    main: defaultNormalizer,
    server: defaultNormalizer,
    tsConfig: defaultNormalizer,
    outputPath: (tree, path, root) => {
        const relativePathFromWorkspaceRoot = (0, path_1.relative)((0, devkit_1.joinPathFragments)(devkit_1.workspaceRoot, root), devkit_1.workspaceRoot);
        return (0, devkit_1.joinPathFragments)(relativePathFromWorkspaceRoot, path);
    },
    proxyConfig: defaultNormalizer,
    polyfills: (tree, paths, root) => {
        const normalizedPaths = [];
        const normalizeFn = (path) => {
            try {
                const resolvedPath = require.resolve(path, {
                    paths: [(0, posix_1.join)(devkit_1.workspaceRoot, 'node_modules')],
                });
                normalizedPaths.push(path);
            }
            catch {
                normalizedPaths.push(normalizeFromProjectRoot(tree, path, root));
            }
        };
        if (typeof paths === 'string') {
            normalizeFn(paths);
        }
        else {
            for (const path of paths) {
                normalizeFn(path);
            }
        }
        return normalizedPaths;
    },
    styles: (tree, paths, root) => {
        const normalizedPaths = [];
        for (const path of paths) {
            if (typeof path === 'string') {
                normalizedPaths.push(normalizeFromProjectRoot(tree, path, root));
            }
            else {
                normalizedPaths.push({
                    input: normalizeFromProjectRoot(tree, path.input, root),
                    bundleName: path.bundleName,
                    inject: path.inject ?? true,
                });
            }
        }
        return normalizedPaths;
    },
    scripts: (tree, paths, root) => {
        const normalizedPaths = [];
        for (const path of paths) {
            if (typeof path === 'string') {
                normalizedPaths.push(normalizeFromProjectRoot(tree, path, root));
            }
            else {
                normalizedPaths.push({
                    input: normalizeFromProjectRoot(tree, path.input, root),
                    bundleName: path.bundleName,
                    inject: path.inject ?? true,
                });
            }
        }
        return normalizedPaths;
    },
    assets: (tree, paths, root) => {
        const normalizedPaths = [];
        for (const path of paths) {
            if (typeof path === 'string') {
                normalizedPaths.push(normalizeFromProjectRoot(tree, path, root));
            }
            else {
                normalizedPaths.push({
                    ...path,
                    input: normalizeFromProjectRoot(tree, path.input, root),
                });
            }
        }
        return normalizedPaths;
    },
    fileReplacements: (tree, paths, root) => {
        const normalizedPaths = [];
        for (const path of paths) {
            normalizedPaths.push({
                replace: normalizeFromProjectRoot(tree, 'src' in path ? path.src : path.replace, root),
                with: normalizeFromProjectRoot(tree, 'replaceWith' in path ? path.replaceWith : path.with, root),
            });
        }
        return normalizedPaths;
    },
};
function handleBuildTargetOptions(tree, options, newConfigurationOptions, root) {
    let customWebpackConfigPath;
    if (!options || Object.keys(options).length === 0) {
        return customWebpackConfigPath;
    }
    if (options.customWebpackConfig) {
        customWebpackConfigPath = options.customWebpackConfig.path;
        delete options.customWebpackConfig;
    }
    if (options.outputs) {
        // handled by the Rspack inference plugin
        delete options.outputs;
    }
    for (const [key, value] of Object.entries(options)) {
        let optionName = key;
        let optionValue = key in PATH_NORMALIZER ? PATH_NORMALIZER[key](tree, value, root) : value;
        if (REMOVED_OPTIONS.includes(key)) {
            continue;
        }
        if (key in RENAMED_OPTIONS) {
            optionName = RENAMED_OPTIONS[key];
        }
        newConfigurationOptions[optionName] = optionValue;
    }
    if (typeof newConfigurationOptions.polyfills === 'string') {
        newConfigurationOptions.polyfills = [newConfigurationOptions.polyfills];
    }
    let outputPath = newConfigurationOptions.outputPath;
    if (typeof outputPath === 'string') {
        if (!/\/browser\/?$/.test(outputPath)) {
            console.warn(`The output location of the browser build has been updated from "${outputPath}" to ` +
                `"${(0, posix_1.join)(outputPath, 'browser')}". ` +
                'You might need to adjust your deployment pipeline or, as an alternative, ' +
                'set outputPath.browser to "" in order to maintain the previous functionality.');
        }
        else {
            outputPath = outputPath.replace(/\/browser\/?$/, '');
        }
        newConfigurationOptions['outputPath'] = {
            base: outputPath,
        };
        if (typeof newConfigurationOptions.resourcesOutputPath === 'string') {
            const media = newConfigurationOptions.resourcesOutputPath.replaceAll('/', '');
            if (media && media !== 'media') {
                newConfigurationOptions['outputPath'] = {
                    base: outputPath,
                    media,
                };
            }
        }
    }
    return customWebpackConfigPath;
}
function handleDevServerTargetOptions(tree, options, newConfigurationOptions, root) {
    for (const [key, value] of Object.entries(options)) {
        let optionName = key;
        let optionValue = key in PATH_NORMALIZER ? PATH_NORMALIZER[key](tree, value, root) : value;
        if (REMOVED_OPTIONS.includes(key)) {
            continue;
        }
        if (key in RENAMED_OPTIONS) {
            optionName = RENAMED_OPTIONS[key];
        }
        newConfigurationOptions[optionName] = optionValue;
    }
}
async function getProjectToConvert(tree) {
    const projects = new Set();
    for (const executor of SUPPORTED_EXECUTORS) {
        (0, executor_options_utils_1.forEachExecutorOptions)(tree, executor, (_, project) => {
            projects.add(project);
        });
    }
    const { project } = await (0, enquirer_1.prompt)({
        type: 'select',
        name: 'project',
        message: 'Which project would you like to convert to rspack?',
        choices: Array.from(projects),
    });
    return project;
}
async function convertToRspack(tree, schema) {
    let { project: projectName } = schema;
    if (!projectName) {
        projectName = await getProjectToConvert(tree);
    }
    const project = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const tasks = [];
    const createConfigOptions = {
        root: project.root,
    };
    const configurationOptions = {};
    const buildTargetNames = [];
    const serveTargetNames = [];
    let customWebpackConfigPath;
    (0, validate_supported_executor_1.validateSupportedBuildExecutor)(Object.values(project.targets));
    let projectServePort = DEFAULT_PORT;
    for (const [targetName, target] of Object.entries(project.targets)) {
        if (target.executor === '@angular-devkit/build-angular:browser' ||
            target.executor === '@nx/angular:webpack-browser') {
            customWebpackConfigPath = handleBuildTargetOptions(tree, target.options, createConfigOptions, project.root);
            if (target.configurations) {
                for (const [configurationName, configuration] of Object.entries(target.configurations)) {
                    configurationOptions[configurationName] = {};
                    handleBuildTargetOptions(tree, configuration, configurationOptions[configurationName], project.root);
                }
            }
            buildTargetNames.push(targetName);
        }
        else if (target.executor === '@angular-devkit/build-angular:server' ||
            target.executor === '@nx/angular:webpack-server') {
            createConfigOptions.ssr ??= {};
            createConfigOptions.ssr.entry ??= normalizeFromProjectRoot(tree, target.options.main, project.root);
            createConfigOptions.server = './src/main.server.ts';
            buildTargetNames.push(targetName);
        }
        else if (target.executor === '@angular-devkit/build-angular:dev-server' ||
            target.executor === '@nx/angular:dev-server' ||
            target.executor === '@nx/angular:module-federation-dev-server') {
            createConfigOptions.devServer = {};
            if (target.options) {
                handleDevServerTargetOptions(tree, target.options, createConfigOptions.devServer, project.root);
                if (target.options.port !== DEFAULT_PORT) {
                    projectServePort = target.options.port;
                }
            }
            if (target.configurations) {
                for (const [configurationName, configuration] of Object.entries(target.configurations)) {
                    configurationOptions[configurationName] ??= {};
                    configurationOptions[configurationName].devServer ??= {};
                    handleDevServerTargetOptions(tree, configuration, configurationOptions[configurationName].devServer, project.root);
                }
            }
            serveTargetNames.push(targetName);
        }
    }
    const customWebpackConfigInfo = customWebpackConfigPath
        ? await (0, get_custom_webpack_config_1.getCustomWebpackConfig)(tree, project.root, customWebpackConfigPath)
        : undefined;
    (0, create_config_1.createConfig)(tree, createConfigOptions, configurationOptions, customWebpackConfigInfo?.normalizedPathToCustomWebpackConfig, customWebpackConfigInfo?.isWebpackConfigFunction);
    (0, update_tsconfig_1.updateTsconfig)(tree, project.root);
    for (const targetName of [...buildTargetNames, ...serveTargetNames]) {
        delete project.targets[targetName];
    }
    if (projectServePort !== DEFAULT_PORT) {
        project.targets.serve ??= {};
        project.targets.serve.options ??= {};
        project.targets.serve.options.port = projectServePort;
    }
    (0, devkit_1.updateProjectConfiguration)(tree, projectName, project);
    const { rspackInitGenerator } = (0, devkit_1.ensurePackage)('@nx/rspack', versions_1.nxVersion);
    await rspackInitGenerator(tree, {
        addPlugin: true,
    });
    // This is needed to prevent a circular execution of the build target
    const rootPkgJson = (0, devkit_1.readJson)(tree, 'package.json');
    if (rootPkgJson.scripts?.build === 'nx build') {
        delete rootPkgJson.scripts.build;
        (0, devkit_1.writeJson)(tree, 'package.json', rootPkgJson);
    }
    if (!schema.skipInstall) {
        const installTask = (0, devkit_1.addDependenciesToPackageJson)(tree, {}, {
            '@nx/angular-rspack': versions_1.angularRspackVersion,
            'ts-node': versions_1.tsNodeVersion,
        });
        tasks.push(installTask);
    }
    if (!schema.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.default = convertToRspack;
