"use strict";
// All credit goes to the incredible folks at Nx who use this code to update the app styles when adding tailwind
// Check out the code here: https://github.com/nrwl/nx/blob/master/packages/angular/src/generators/setup-tailwind/lib/update-application-styles.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.addThemeToApplicationStyles = addThemeToApplicationStyles;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const semver = tslib_1.__importStar(require("semver"));
const supported_theme_generator_map_1 = require("./supported-theme-generator-map");
function addThemeToApplicationStyles(tree, options, project) {
    const packageJson = (0, devkit_1.readJson)(tree, 'package.json');
    let tailwindVersion = 3;
    if ('tailwindcss' in packageJson.devDependencies) {
        const version = packageJson.devDependencies['tailwindcss'];
        tailwindVersion = semver.coerce(version)?.major ?? 3;
    }
    const tailwindImport = tailwindVersion === 4 ? '@import "@spartan-ng/brain/hlm-tailwind-preset.css";' : '';
    const prefix = options.prefix ? ` .${options.prefix}` : '';
    let stylesEntryPoint = options.stylesEntryPoint;
    if (stylesEntryPoint && !tree.exists(stylesEntryPoint)) {
        throw new Error(`The provided styles entry point "${stylesEntryPoint}" could not be found.`);
    }
    if (!stylesEntryPoint) {
        stylesEntryPoint = findStylesEntryPoint(tree, project);
        if (!stylesEntryPoint) {
            throw new Error((0, devkit_1.stripIndents) `Could not find a styles entry point for project "${options.project}".
        Please specify a styles entry point using the "stylesEntryPoint" option.`);
        }
    }
    const stylesEntryPointContent = tree.read(stylesEntryPoint, 'utf-8');
    const CDK_IMPORT = `@import '@angular/cdk/overlay-prebuilt.css';`;
    const ckdOverlayImport = stylesEntryPointContent.includes(CDK_IMPORT) ? '' : CDK_IMPORT;
    const rootFontSans = stylesEntryPointContent.includes('--font-sans')
        ? ''
        : `:root {
     --font-sans: ''
     }`;
    tree.write(stylesEntryPoint, (0, devkit_1.stripIndents) `
    ${ckdOverlayImport}

    ${stylesEntryPointContent}
    ${tailwindImport}

    ${rootFontSans}
    ${supported_theme_generator_map_1.SupportedThemeGeneratorMap[options.theme](options.radius, prefix)}

    @layer base {
      * {
        @apply border-border;
      }
    }`);
}
function findStylesEntryPoint(tree, project) {
    // first check for common names
    const possibleStylesEntryPoints = [
        (0, devkit_1.joinPathFragments)(project.sourceRoot ?? project.root, 'styles.css'),
        (0, devkit_1.joinPathFragments)(project.sourceRoot ?? project.root, 'styles.scss'),
        (0, devkit_1.joinPathFragments)(project.sourceRoot ?? project.root, 'styles.sass'),
        (0, devkit_1.joinPathFragments)(project.sourceRoot ?? project.root, 'styles.less'),
    ];
    const stylesEntryPoint = possibleStylesEntryPoints.find((s) => tree.exists(s));
    if (stylesEntryPoint) {
        return stylesEntryPoint;
    }
    // then check for the specified styles in the build configuration if it exists
    const styles = project.targets?.build.options?.styles;
    if (!styles) {
        return undefined;
    }
    // find the first style that belongs to the project source
    const style = styles.find((s) => typeof s === 'string'
        ? s.startsWith(project.root) && tree.exists(s)
        : s.input.startsWith(project.root) && s.inject !== false && tree.exists(s.input));
    if (!style) {
        return undefined;
    }
    return typeof style === 'string' ? style : style.input;
}
//# sourceMappingURL=add-theme-to-application-styles.js.map