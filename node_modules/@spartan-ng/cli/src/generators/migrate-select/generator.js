"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateSelectGenerator = migrateSelectGenerator;
const devkit_1 = require("@nx/devkit");
const hlm_class_1 = require("../../utils/hlm-class");
const visit_files_1 = require("../../utils/visit-files");
async function migrateSelectGenerator(tree, { skipFormat }) {
    replaceOpenChangeEvent(tree);
    replaceFocusClasses(tree);
    if (!skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
}
function replaceOpenChangeEvent(tree) {
    // if the element is `<brn-select`, '<hlm-select' and it has an `(openedChange)` event, we need to replace it with `(openChange)`
    (0, visit_files_1.visitFiles)(tree, '.', (path) => {
        // if this is not an html file or typescript file (inline templates) then skip
        if (!path.endsWith('.html') && !path.endsWith('.ts')) {
            return;
        }
        let content = tree.read(path, 'utf-8');
        if (!content) {
            return;
        }
        // find all the brn-select or hlm-select elements that have an `(openedChange)` event
        content = content.replace(/<(brn-select|hlm-select)[^>]*\(\s*openedChange\s*\)=/g, (match) => match.replace(/\(\s*openedChange\s*\)/, '(openChange)'));
        tree.write(path, content);
    });
}
function replaceFocusClasses(tree) {
    // update the hlm classes
    (0, visit_files_1.visitFiles)(tree, '.', (path) => {
        // if this is not a typescript file then skip
        if (!path.endsWith('.ts')) {
            return;
        }
        (0, hlm_class_1.updateHelmClasses)(tree, path, {
            component: 'HlmSelectOptionComponent',
            classesToRemove: ['focus:bg-accent', 'focus:text-accent-foreground'],
            classesToAdd: ['data-[active]:bg-accent', 'data-[active]:text-accent-foreground'],
        });
    });
}
exports.default = migrateSelectGenerator;
//# sourceMappingURL=generator.js.map