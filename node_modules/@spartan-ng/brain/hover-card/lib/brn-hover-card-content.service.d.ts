import { type ConnectedOverlayPositionChange, type ConnectedPosition, type OverlayConfig } from '@angular/cdk/overlay';
import { ElementRef, type OnDestroy, type OnInit, type Signal, TemplateRef, ViewContainerRef } from '@angular/core';
import { type ExposesSide, type ExposesState } from '@spartan-ng/brain/core';
import { Observable } from 'rxjs';
import * as i0 from "@angular/core";
export declare class BrnHoverCardContentDirective implements ExposesState, ExposesSide {
    private readonly _contentService;
    readonly state: Signal<"open" | "closed">;
    readonly side: Signal<"top" | "bottom" | "left" | "right">;
    readonly template: TemplateRef<any>;
    static ɵfac: i0.ɵɵFactoryDeclaration<BrnHoverCardContentDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<BrnHoverCardContentDirective, "[brnHoverCardContent]", ["brnHoverCardContent"], {}, {}, never, never, true, never>;
}
/**
 * We are building on shoulders of giants here and use the implementation provided by the incredible TaigaUI
 * team: https://github.com/taiga-family/taiga-ui/blob/main/projects/core/directives/dropdown/dropdown-hover.directive.ts
 * Check them out! Give them a try! Leave a star! Their work is incredible!
 */
export type BrnHoverCardOptions = Partial<{
    attachTo: ElementRef;
    attachPositions: ConnectedPosition[];
    align: 'top' | 'bottom';
    sideOffset: number;
} & OverlayConfig>;
export declare class BrnHoverCardContentService {
    private readonly _overlay;
    private readonly _zone;
    private readonly _psBuilder;
    private readonly _content;
    private readonly _state;
    private _config;
    private _overlayRef?;
    private _positionStrategy?;
    private _destroyed$;
    private readonly _positionChangesObservables$;
    private readonly _overlayHoveredObservables$;
    readonly positionChanges$: Observable<ConnectedOverlayPositionChange>;
    readonly hovered$: Observable<boolean>;
    readonly state: Signal<"open" | "closed">;
    readonly side: Signal<'top' | 'bottom' | 'left' | 'right'>;
    setConfig(config: BrnHoverCardOptions): void;
    setContent(value: TemplateRef<unknown> | BrnHoverCardContentDirective, vcr: ViewContainerRef): void;
    setState(newState: 'open' | 'closed'): void;
    show(): void;
    hide(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<BrnHoverCardContentService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<BrnHoverCardContentService>;
}
export declare class BrnHoverCardTriggerDirective implements OnInit, OnDestroy {
    private readonly _destroy$;
    private readonly _vcr;
    private readonly _zone;
    private readonly _el;
    private readonly _contentService;
    private readonly _focusMonitor;
    readonly focused$: Observable<boolean>;
    readonly hovered$: Observable<boolean>;
    readonly showing$: Observable<boolean>;
    showDelay: import("@angular/core").InputSignal<number>;
    hideDelay: import("@angular/core").InputSignal<number>;
    animationDelay: import("@angular/core").InputSignal<number>;
    sideOffset: import("@angular/core").InputSignal<number>;
    align: import("@angular/core").InputSignal<"top" | "bottom">;
    readonly brnHoverCardTriggerFor: import("@angular/core").InputSignal<BrnHoverCardContentDirective | TemplateRef<unknown> | undefined>;
    readonly mutableBrnHoverCardTriggerFor: Signal<import("@angular/core").WritableSignal<BrnHoverCardContentDirective | TemplateRef<unknown> | undefined>>;
    private readonly _brnHoverCardTriggerForState;
    constructor();
    ngOnInit(): void;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<BrnHoverCardTriggerDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<BrnHoverCardTriggerDirective, "[brnHoverCardTrigger]:not(ng-container),[brnHoverCardTriggerFor]:not(ng-container)", ["brnHoverCardTrigger"], { "showDelay": { "alias": "showDelay"; "required": false; "isSignal": true; }; "hideDelay": { "alias": "hideDelay"; "required": false; "isSignal": true; }; "animationDelay": { "alias": "animationDelay"; "required": false; "isSignal": true; }; "sideOffset": { "alias": "sideOffset"; "required": false; "isSignal": true; }; "align": { "alias": "align"; "required": false; "isSignal": true; }; "brnHoverCardTriggerFor": { "alias": "brnHoverCardTriggerFor"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}
