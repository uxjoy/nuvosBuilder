import { BooleanInput } from '@angular/cdk/coercion';
import { ElementRef, type OnDestroy } from '@angular/core';
import * as i0 from "@angular/core";
export declare class BrnRadioChange<T> {
    source: BrnRadioComponent<T>;
    value: T;
    constructor(source: BrnRadioComponent<T>, value: T);
}
export declare class BrnRadioComponent<T = unknown> implements OnDestroy {
    private static _nextUniqueId;
    private readonly _focusMonitor;
    private readonly _elementRef;
    protected readonly radioGroup: import("@spartan-ng/brain/radio-group").BrnRadioGroupDirective<T>;
    /**
     * Whether the radio button is disabled.
     */
    readonly disabled: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Whether the radio button is disabled or the radio group is disabled.
     */
    protected readonly disabledState: import("@angular/core").Signal<boolean>;
    /**
     * Whether the radio button is checked.
     */
    protected readonly checked: import("@angular/core").Signal<boolean>;
    protected readonly tabIndex: import("@angular/core").Signal<0 | -1>;
    /**
     * The unique ID for the radio button input. If none is supplied, it will be auto-generated.
     */
    readonly id: import("@angular/core").InputSignal<string | undefined>;
    readonly ariaLabel: import("@angular/core").InputSignal<string | undefined>;
    readonly ariaLabelledby: import("@angular/core").InputSignal<string | undefined>;
    readonly ariaDescribedby: import("@angular/core").InputSignal<string | undefined>;
    /**
     * The value this radio button represents.
     */
    readonly value: import("@angular/core").InputSignal<T>;
    /**
     * Whether the radio button is required.
     */
    readonly required: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Event emitted when the checked state of this radio button changes.
     */
    readonly change: import("@angular/core").OutputEmitterRef<BrnRadioChange<T>>;
    protected readonly hostId: import("@angular/core").Signal<string | undefined>;
    protected readonly inputId: import("@angular/core").Signal<string>;
    protected readonly inputElement: import("@angular/core").Signal<ElementRef<HTMLInputElement>>;
    constructor();
    ngOnDestroy(): void;
    /** Dispatch change event with current value. */
    private emitChangeEvent;
    protected onInputClick(event: Event): void;
    protected onInputInteraction(event: Event): void;
    /** Triggered when the user clicks on the touch target. */
    protected onTouchTargetClick(event: Event): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<BrnRadioComponent<any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<BrnRadioComponent<any>, "brn-radio", ["brnRadio"], { "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; "id": { "alias": "id"; "required": false; "isSignal": true; }; "ariaLabel": { "alias": "aria-label"; "required": false; "isSignal": true; }; "ariaLabelledby": { "alias": "aria-labelledby"; "required": false; "isSignal": true; }; "ariaDescribedby": { "alias": "aria-describedby"; "required": false; "isSignal": true; }; "value": { "alias": "value"; "required": true; "isSignal": true; }; "required": { "alias": "required"; "required": false; "isSignal": true; }; }, { "change": "change"; }, never, ["[target],[indicator]", "*"], true, never>;
}
