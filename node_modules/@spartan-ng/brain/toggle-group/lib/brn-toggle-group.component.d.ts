import { BooleanInput } from '@angular/cdk/coercion';
import { type ControlValueAccessor } from '@angular/forms';
import { BrnToggleGroupItemDirective } from './brn-toggle-item.directive';
import * as i0 from "@angular/core";
export declare const BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR: {
    provide: import("@angular/core").InjectionToken<readonly ControlValueAccessor[]>;
    useExisting: import("@angular/core").Type<any>;
    multi: boolean;
};
export declare class BrnButtonToggleChange<T = unknown> {
    source: BrnToggleGroupItemDirective<T>;
    value: ToggleValue<T>;
    constructor(source: BrnToggleGroupItemDirective<T>, value: ToggleValue<T>);
}
export declare class BrnToggleGroupComponent<T = unknown> implements ControlValueAccessor {
    /**
     * The method to be called in order to update ngModel.
     */
    private _onChange;
    /** onTouch function registered via registerOnTouch (ControlValueAccessor). */
    protected onTouched: () => void;
    /** Whether the button toggle group has a vertical orientation */
    readonly vertical: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /** Value of the toggle group. */
    readonly value: import("@angular/core").ModelSignal<ToggleValue<T>>;
    /** Whether no button toggles need to be selected. */
    readonly nullable: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /** Whether multiple button toggles can be selected. */
    readonly multiple: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /** Whether the button toggle group is disabled. */
    readonly disabled: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /** The internal state of the component. This can be replaced with linkedSignal in the future. */
    readonly state: import("@angular/core").Signal<{
        disabled: import("@angular/core").WritableSignal<boolean>;
    }>;
    /** Emit event when the group value changes. */
    readonly change: import("@angular/core").OutputEmitterRef<BrnButtonToggleChange<T>>;
    writeValue(value: ToggleValue<T>): void;
    registerOnChange(fn: (value: ToggleValue<T>) => void): void;
    registerOnTouched(fn: () => void): void;
    setDisabledState(isDisabled: boolean): void;
    /**
     * @internal
     * Determines whether a value can be set on the group.
     */
    canDeselect(value: ToggleValue<T>): boolean;
    /**
     * @internal
     * Selects a value.
     */
    select(value: T, source: BrnToggleGroupItemDirective<T>): void;
    /**
     * @internal
     * Deselects a value.
     */
    deselect(value: T, source: BrnToggleGroupItemDirective<T>): void;
    /**
     * @internal
     * Determines whether a value is selected.
     */
    isSelected(value: T): boolean;
    /** Update the value of the group */
    private emitSelectionChange;
    static ɵfac: i0.ɵɵFactoryDeclaration<BrnToggleGroupComponent<any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<BrnToggleGroupComponent<any>, "brn-toggle-group", ["brnToggleGroup"], { "vertical": { "alias": "vertical"; "required": false; "isSignal": true; }; "value": { "alias": "value"; "required": false; "isSignal": true; }; "nullable": { "alias": "nullable"; "required": false; "isSignal": true; }; "multiple": { "alias": "multiple"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; }, { "value": "valueChange"; "change": "change"; }, never, ["*"], true, never>;
}
type ToggleValue<T> = T | T[] | null | undefined;
export {};
