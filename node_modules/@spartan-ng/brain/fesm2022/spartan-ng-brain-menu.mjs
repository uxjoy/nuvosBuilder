import * as i0 from '@angular/core';
import { inject, input, effect, Directive, booleanAttribute, signal, NgModule } from '@angular/core';
import * as i1 from '@angular/cdk/menu';
import { CdkContextMenuTrigger, CdkMenuBar, CdkMenuGroup, CdkMenuItemCheckbox, CdkMenuItemRadio, CdkMenuItem, CdkMenuTrigger, CdkMenu } from '@angular/cdk/menu';
import { takeUntilDestroyed, outputFromObservable } from '@angular/core/rxjs-interop';

const getBrnMenuAlign = (align) => [
    {
        originX: align,
        originY: 'bottom',
        overlayX: align,
        overlayY: 'top',
    },
    {
        originX: align,
        originY: 'top',
        overlayX: align,
        overlayY: 'bottom',
    },
];

class BrnContextMenuTriggerDirective {
    _cdkTrigger = inject(CdkContextMenuTrigger, { host: true });
    brnCtxMenuTriggerFor = input(null);
    brnCtxMenuTriggerData = input(undefined);
    align = input(undefined);
    constructor() {
        // once the trigger opens we wait until the next tick and then grab the last position
        // used to position the menu. we store this in our trigger which the brnMenu directive has
        // access to through DI
        this._cdkTrigger.opened.pipe(takeUntilDestroyed()).subscribe(() => setTimeout(() => 
        // eslint-disable-next-line
        (this._cdkTrigger._spartanLastPosition = // eslint-disable-next-line
            this._cdkTrigger.overlayRef._positionStrategy._lastPosition)));
        effect(() => (this._cdkTrigger.menuTemplateRef = this.brnCtxMenuTriggerFor()));
        effect(() => (this._cdkTrigger.menuData = this.brnCtxMenuTriggerData()));
        effect(() => {
            const align = this.align();
            if (!align)
                return;
            this._cdkTrigger.menuPosition = getBrnMenuAlign(align);
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnContextMenuTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnContextMenuTriggerDirective, isStandalone: true, selector: "[brnCtxMenuTriggerFor]", inputs: { brnCtxMenuTriggerFor: { classPropertyName: "brnCtxMenuTriggerFor", publicName: "brnCtxMenuTriggerFor", isSignal: true, isRequired: false, transformFunction: null }, brnCtxMenuTriggerData: { classPropertyName: "brnCtxMenuTriggerData", publicName: "brnCtxMenuTriggerData", isSignal: true, isRequired: false, transformFunction: null }, align: { classPropertyName: "align", publicName: "align", isSignal: true, isRequired: false, transformFunction: null } }, hostDirectives: [{ directive: i1.CdkContextMenuTrigger }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnContextMenuTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCtxMenuTriggerFor]',
                    standalone: true,
                    hostDirectives: [CdkContextMenuTrigger],
                }]
        }], ctorParameters: () => [] });

class BrnMenuBarDirective {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuBarDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnMenuBarDirective, isStandalone: true, selector: "[brnMenuBar]", hostDirectives: [{ directive: i1.CdkMenuBar }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuBarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuBar]',
                    standalone: true,
                    hostDirectives: [CdkMenuBar],
                }]
        }] });

class BrnMenuGroupDirective {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuGroupDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnMenuGroupDirective, isStandalone: true, selector: "[brnMenuGroup]", hostDirectives: [{ directive: i1.CdkMenuGroup }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuGroup]',
                    standalone: true,
                    hostDirectives: [CdkMenuGroup],
                }]
        }] });

class BrnMenuItemCheckboxDirective {
    _cdkMenuItem = inject(CdkMenuItemCheckbox);
    checked = input(this._cdkMenuItem.checked, { transform: booleanAttribute });
    disabled = input(this._cdkMenuItem.disabled, { transform: booleanAttribute });
    triggered = outputFromObservable(this._cdkMenuItem.triggered);
    constructor() {
        effect(() => (this._cdkMenuItem.disabled = this.disabled()));
        effect(() => (this._cdkMenuItem.checked = this.checked()));
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuItemCheckboxDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnMenuItemCheckboxDirective, isStandalone: true, selector: "[brnMenuItemCheckbox]", inputs: { checked: { classPropertyName: "checked", publicName: "checked", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { triggered: "triggered" }, host: { properties: { "class.checked": "checked()", "disabled": "disabled()" } }, hostDirectives: [{ directive: i1.CdkMenuItemCheckbox }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuItemCheckboxDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuItemCheckbox]',
                    standalone: true,
                    hostDirectives: [CdkMenuItemCheckbox],
                    host: {
                        '[class.checked]': 'checked()',
                        '[disabled]': 'disabled()',
                    },
                }]
        }], ctorParameters: () => [] });

class BrnMenuItemRadioDirective {
    _cdkMenuItem = inject(CdkMenuItemRadio);
    checked = input(this._cdkMenuItem.checked, { transform: booleanAttribute });
    disabled = input(this._cdkMenuItem.disabled, { transform: booleanAttribute });
    triggered = outputFromObservable(this._cdkMenuItem.triggered);
    constructor() {
        effect(() => (this._cdkMenuItem.disabled = this.disabled()));
        effect(() => (this._cdkMenuItem.checked = this.checked()));
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuItemRadioDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnMenuItemRadioDirective, isStandalone: true, selector: "[brnMenuItemRadio]", inputs: { checked: { classPropertyName: "checked", publicName: "checked", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { triggered: "triggered" }, host: { properties: { "class.checked": "checked()", "disabled": "disabled()" } }, hostDirectives: [{ directive: i1.CdkMenuItemRadio }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuItemRadioDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuItemRadio]',
                    standalone: true,
                    hostDirectives: [CdkMenuItemRadio],
                    host: {
                        '[class.checked]': 'checked()',
                        '[disabled]': 'disabled()',
                    },
                }]
        }], ctorParameters: () => [] });

class BrnMenuItemDirective {
    _cdkMenuItem = inject(CdkMenuItem);
    disabled = input(this._cdkMenuItem.disabled, { transform: booleanAttribute });
    triggered = outputFromObservable(this._cdkMenuItem.triggered);
    constructor() {
        effect(() => (this._cdkMenuItem.disabled = this.disabled()));
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnMenuItemDirective, isStandalone: true, selector: "[brnMenuItem]", inputs: { disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { triggered: "triggered" }, host: { properties: { "disabled": "disabled()" } }, hostDirectives: [{ directive: i1.CdkMenuItem }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuItem]',
                    standalone: true,
                    hostDirectives: [CdkMenuItem],
                    host: {
                        '[disabled]': 'disabled()',
                    },
                }]
        }], ctorParameters: () => [] });

class BrnMenuTriggerDirective {
    _cdkTrigger = inject(CdkMenuTrigger, { host: true });
    align = input(undefined);
    constructor() {
        // once the trigger opens we wait until the next tick and then grab the last position
        // used to position the menu. we store this in our trigger which the brnMenu directive has
        // access to through DI
        this._cdkTrigger.opened.pipe(takeUntilDestroyed()).subscribe(() => setTimeout(() => 
        // eslint-disable-next-line
        (this._cdkTrigger._spartanLastPosition = // eslint-disable-next-line
            this._cdkTrigger.overlayRef._positionStrategy._lastPosition)));
        effect(() => {
            const align = this.align();
            if (!align)
                return;
            this._cdkTrigger.menuPosition = getBrnMenuAlign(align);
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnMenuTriggerDirective, isStandalone: true, selector: "[brnMenuTriggerFor]", inputs: { align: { classPropertyName: "align", publicName: "align", isSignal: true, isRequired: false, transformFunction: null } }, hostDirectives: [{ directive: i1.CdkMenuTrigger, inputs: ["cdkMenuTriggerFor", "brnMenuTriggerFor", "cdkMenuTriggerData", "brnMenuTriggerData"], outputs: ["cdkMenuOpened", "brnMenuOpened", "cdkMenuClosed", "brnMenuClosed"] }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenuTriggerFor]',
                    standalone: true,
                    hostDirectives: [
                        {
                            directive: CdkMenuTrigger,
                            inputs: ['cdkMenuTriggerFor: brnMenuTriggerFor', 'cdkMenuTriggerData: brnMenuTriggerData'],
                            outputs: ['cdkMenuOpened: brnMenuOpened', 'cdkMenuClosed: brnMenuClosed'],
                        },
                    ],
                }]
        }], ctorParameters: () => [] });

class BrnMenuDirective {
    _host = inject(CdkMenu);
    _state = signal('open');
    _side = signal('top');
    constructor() {
        this.setSideWithDarkMagic();
        // this is a best effort, but does not seem to work currently
        // TODO: figure out a way for us to know the host is about to be closed. might not be possible with CDK
        this._host.closed.pipe(takeUntilDestroyed()).subscribe(() => this._state.set('closed'));
    }
    setSideWithDarkMagic() {
        /**
         * This is an ugly workaround to at least figure out the correct side of where a submenu
         * will appear and set the attribute to the host accordingly
         *
         * First of all we take advantage of the menu stack not being aware of the root
         * object immediately after it is added. This code executes before the root element is added,
         * which means the stack is still empty and the peek method returns undefined.
         */
        const isRoot = this._host.menuStack.peek() === undefined;
        setTimeout(() => {
            // our menu trigger directive leaves the last position used for use immediately after opening
            // we can access it here and determine the correct side.
            // eslint-disable-next-line
            const ps = this._host._parentTrigger._spartanLastPosition;
            if (!ps) {
                // if we have no last position we default to the most likely option
                // I hate that we have to do this and hope we can revisit soon and improve
                this._side.set(isRoot ? 'top' : 'left');
                return;
            }
            const side = isRoot ? ps.originY : ps.originX === 'end' ? 'right' : 'left';
            this._side.set(side);
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnMenuDirective, isStandalone: true, selector: "[brnMenu],[brnSubMenu]", host: { properties: { "attr.data-state": "_state()", "attr.data-side": "_side()" } }, hostDirectives: [{ directive: i1.CdkMenu }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnMenu],[brnSubMenu]',
                    standalone: true,
                    host: {
                        '[attr.data-state]': '_state()',
                        '[attr.data-side]': '_side()',
                    },
                    hostDirectives: [CdkMenu],
                }]
        }], ctorParameters: () => [] });

const BrnMenuItemImports = [
    BrnMenuGroupDirective,
    BrnMenuItemDirective,
    BrnMenuItemRadioDirective,
    BrnMenuItemCheckboxDirective,
];
const BrnMenuImports = [BrnMenuTriggerDirective, BrnMenuDirective, ...BrnMenuItemImports];
const BrnMenuBarImports = [...BrnMenuImports, BrnMenuBarDirective];
const BrnContextMenuImports = [...BrnMenuImports, BrnContextMenuTriggerDirective];
class BrnMenuItemModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuItemModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuItemModule, imports: [BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective], exports: [BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuItemModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuItemModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnMenuItemImports],
                    exports: [...BrnMenuItemImports],
                }]
        }] });
class BrnMenuModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuModule, imports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective], exports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnMenuImports],
                    exports: [...BrnMenuImports],
                }]
        }] });
class BrnMenuBarModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuBarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuBarModule, imports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective, BrnMenuBarDirective], exports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective, BrnMenuBarDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuBarModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnMenuBarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnMenuBarImports],
                    exports: [...BrnMenuBarImports],
                }]
        }] });
class BrnContextMenuModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnContextMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnContextMenuModule, imports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective, BrnContextMenuTriggerDirective], exports: [BrnMenuTriggerDirective, BrnMenuDirective, BrnMenuGroupDirective,
            BrnMenuItemDirective,
            BrnMenuItemRadioDirective,
            BrnMenuItemCheckboxDirective, BrnContextMenuTriggerDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnContextMenuModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnContextMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnContextMenuImports],
                    exports: [...BrnContextMenuImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnContextMenuImports, BrnContextMenuModule, BrnContextMenuTriggerDirective, BrnMenuBarDirective, BrnMenuBarImports, BrnMenuBarModule, BrnMenuDirective, BrnMenuGroupDirective, BrnMenuImports, BrnMenuItemCheckboxDirective, BrnMenuItemDirective, BrnMenuItemImports, BrnMenuItemModule, BrnMenuItemRadioDirective, BrnMenuModule, BrnMenuTriggerDirective };
//# sourceMappingURL=spartan-ng-brain-menu.mjs.map
