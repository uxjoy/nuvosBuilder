import * as i0 from '@angular/core';
import { InjectionToken, inject, ElementRef, input, booleanAttribute, computed, output, viewChild, ChangeDetectionStrategy, ViewEncapsulation, Component, forwardRef, model, linkedSignal, contentChildren, Directive, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { FocusMonitor } from '@angular/cdk/a11y';

const BrnRadioGroupToken = new InjectionToken('BrnRadioGroupToken');
function provideBrnRadioGroupToken(directive) {
    return { provide: BrnRadioGroupToken, useExisting: directive };
}
function injectBrnRadioGroup() {
    return inject(BrnRadioGroupToken);
}

class BrnRadioChange {
    source;
    value;
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
class BrnRadioComponent {
    static _nextUniqueId = 0;
    _focusMonitor = inject(FocusMonitor);
    _elementRef = inject(ElementRef);
    radioGroup = injectBrnRadioGroup();
    /**
     * Whether the radio button is disabled.
     */
    disabled = input(false, { transform: booleanAttribute });
    /**
     * Whether the radio button is disabled or the radio group is disabled.
     */
    disabledState = computed(() => this.disabled() || this.radioGroup.disabledState());
    /**
     * Whether the radio button is checked.
     */
    checked = computed(() => this.radioGroup.value() === this.value());
    tabIndex = computed(() => {
        const disabled = this.disabledState();
        const checked = this.checked();
        const hasSelectedRadio = this.radioGroup.value() !== undefined;
        const isFirstRadio = this.radioGroup.radioButtons()[0] === this;
        if (disabled || (!checked && (hasSelectedRadio || !isFirstRadio))) {
            return -1;
        }
        return 0;
    });
    /**
     * The unique ID for the radio button input. If none is supplied, it will be auto-generated.
     */
    id = input(undefined);
    ariaLabel = input(undefined, { alias: 'aria-label' });
    ariaLabelledby = input(undefined, { alias: 'aria-labelledby' });
    ariaDescribedby = input(undefined, { alias: 'aria-describedby' });
    /**
     * The value this radio button represents.
     */
    value = input.required();
    /**
     * Whether the radio button is required.
     */
    required = input(false, {
        transform: booleanAttribute,
    });
    /**
     * Event emitted when the checked state of this radio button changes.
     */
    change = output();
    hostId = computed(() => this.id() ? this.id() : `brn-radio-${++BrnRadioComponent._nextUniqueId}`);
    inputId = computed(() => `${this.hostId()}-input`);
    inputElement = viewChild.required('input');
    constructor() {
        this._focusMonitor.monitor(this._elementRef, true);
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    /** Dispatch change event with current value. */
    emitChangeEvent() {
        this.change.emit(new BrnRadioChange(this, this.value()));
    }
    onInputClick(event) {
        // We have to stop propagation for click events on the visual hidden input element.
        // By default, when a user clicks on a label element, a generated click event will be
        // dispatched on the associated input element. Since we are using a label element as our
        // root container, the click event on the `radio-button` will be executed twice.
        // The real click event will bubble up, and the generated click event also tries to bubble up.
        // This will lead to multiple click events.
        // Preventing bubbling for the second event will solve that issue.
        event.stopPropagation();
    }
    onInputInteraction(event) {
        // We always have to stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        // emit its event object to the `change` output.
        event.stopPropagation();
        if (!this.checked() && !this.disabledState()) {
            this.emitChangeEvent();
            this.radioGroup.select(this, this.value());
        }
    }
    /** Triggered when the user clicks on the touch target. */
    onTouchTargetClick(event) {
        this.onInputInteraction(event);
        if (!this.disabledState()) {
            // Normally the input should be focused already, but if the click
            // comes from the touch target, then we might have to focus it ourselves.
            this.inputElement().nativeElement.focus();
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnRadioComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.8", type: BrnRadioComponent, isStandalone: true, selector: "brn-radio", inputs: { disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, ariaLabel: { classPropertyName: "ariaLabel", publicName: "aria-label", isSignal: true, isRequired: false, transformFunction: null }, ariaLabelledby: { classPropertyName: "ariaLabelledby", publicName: "aria-labelledby", isSignal: true, isRequired: false, transformFunction: null }, ariaDescribedby: { classPropertyName: "ariaDescribedby", publicName: "aria-describedby", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: true, transformFunction: null }, required: { classPropertyName: "required", publicName: "required", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { change: "change" }, host: { listeners: { "focus": "inputElement().nativeElement.focus()" }, properties: { "attr.id": "hostId()", "class.brn-radio-checked": "checked()", "class.brn-radio-disabled": "disabledState()", "attr.data-checked": "checked()", "attr.data-disabled": "disabledState()", "attr.data-value": "value()", "attr.tabindex": "null", "attr.aria-label": "null", "attr.aria-labelledby": "null", "attr.aria-describedby": "null" }, classAttribute: "brn-radio" }, viewQueries: [{ propertyName: "inputElement", first: true, predicate: ["input"], descendants: true, isSignal: true }], exportAs: ["brnRadio"], ngImport: i0, template: `
		<div
			data-slot="indicator"
			style="display: flex; height: fit-content; width: fit-content"
			(click)="onTouchTargetClick($event)"
		>
			<ng-content select="[target],[indicator]" />
		</div>
		<input
			#input
			style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;"
			type="radio"
			[id]="inputId()"
			[checked]="checked()"
			[disabled]="disabledState()"
			[tabIndex]="tabIndex()"
			[attr.name]="radioGroup.name()"
			[attr.value]="value()"
			[required]="required()"
			[attr.aria-label]="ariaLabel()"
			[attr.aria-labelledby]="ariaLabelledby()"
			[attr.aria-describedby]="ariaDescribedby()"
			(change)="onInputInteraction($event)"
			(click)="onInputClick($event)"
		/>
		<label [for]="inputId()" data-slot="label">
			<ng-content />
		</label>
	`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnRadioComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-radio',
                    standalone: true,
                    host: {
                        class: 'brn-radio',
                        '[attr.id]': 'hostId()',
                        '[class.brn-radio-checked]': 'checked()',
                        '[class.brn-radio-disabled]': 'disabledState()',
                        '[attr.data-checked]': 'checked()',
                        '[attr.data-disabled]': 'disabledState()',
                        '[attr.data-value]': 'value()',
                        // Needs to be removed since it causes some a11y issues (see #21266).
                        '[attr.tabindex]': 'null',
                        '[attr.aria-label]': 'null',
                        '[attr.aria-labelledby]': 'null',
                        '[attr.aria-describedby]': 'null',
                        // Note: under normal conditions focus shouldn't land on this element, however it may be
                        // programmatically set, for example inside of a focus trap, in this case we want to forward
                        // the focus to the native element.
                        '(focus)': 'inputElement().nativeElement.focus()',
                    },
                    exportAs: 'brnRadio',
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
		<div
			data-slot="indicator"
			style="display: flex; height: fit-content; width: fit-content"
			(click)="onTouchTargetClick($event)"
		>
			<ng-content select="[target],[indicator]" />
		</div>
		<input
			#input
			style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;"
			type="radio"
			[id]="inputId()"
			[checked]="checked()"
			[disabled]="disabledState()"
			[tabIndex]="tabIndex()"
			[attr.name]="radioGroup.name()"
			[attr.value]="value()"
			[required]="required()"
			[attr.aria-label]="ariaLabel()"
			[attr.aria-labelledby]="ariaLabelledby()"
			[attr.aria-describedby]="ariaDescribedby()"
			(change)="onInputInteraction($event)"
			(click)="onInputClick($event)"
		/>
		<label [for]="inputId()" data-slot="label">
			<ng-content />
		</label>
	`,
                }]
        }], ctorParameters: () => [] });

const BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => BrnRadioGroupDirective),
    multi: true,
};
class BrnRadioGroupDirective {
    static _nextUniqueId = 0;
    onChange = () => { };
    onTouched = () => { };
    name = input(`brn-radio-group-${BrnRadioGroupDirective._nextUniqueId++}`);
    /**
     * The value of the selected radio button.
     */
    value = model();
    /**
     * Whether the radio group is disabled.
     */
    disabled = input(false, {
        transform: booleanAttribute,
    });
    /**
     * Whether the radio group should be required.
     */
    required = input(false, {
        transform: booleanAttribute,
    });
    /**
     * The direction of the radio group.
     */
    direction = input('ltr');
    /**
     * Event emitted when the group value changes.
     */
    change = output();
    /**
     * The internal disabled state of the radio group. This could be switched to a linkedSignal when we can drop v18 support.
     * @internal
     */
    disabledState = linkedSignal(() => this.disabled());
    /**
     * Access the radio buttons within the group.
     * @internal
     */
    radioButtons = contentChildren(BrnRadioComponent, { descendants: true });
    writeValue(value) {
        this.value.set(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabledState.set(isDisabled);
    }
    /**
     * Select a radio button.
     * @internal
     */
    select(radioButton, value) {
        if (this.value() === value) {
            return;
        }
        this.value.set(value);
        this.onChange(value);
        this.change.emit(new BrnRadioChange(radioButton, value));
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnRadioGroupDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.8", type: BrnRadioGroupDirective, isStandalone: true, selector: "[brnRadioGroup]", inputs: { name: { classPropertyName: "name", publicName: "name", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, required: { classPropertyName: "required", publicName: "required", isSignal: true, isRequired: false, transformFunction: null }, direction: { classPropertyName: "direction", publicName: "direction", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { value: "valueChange", change: "change" }, host: { attributes: { "role": "radiogroup" }, listeners: { "focusout": "onTouched()" }, properties: { "dir": "direction()" } }, providers: [BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, provideBrnRadioGroupToken(BrnRadioGroupDirective)], queries: [{ propertyName: "radioButtons", predicate: BrnRadioComponent, descendants: true, isSignal: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnRadioGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnRadioGroup]',
                    standalone: true,
                    providers: [BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, provideBrnRadioGroupToken(BrnRadioGroupDirective)],
                    host: {
                        role: 'radiogroup',
                        '[dir]': 'direction()',
                        '(focusout)': 'onTouched()',
                    },
                }]
        }] });

const BrnRadioGroupImports = [BrnRadioGroupDirective, BrnRadioComponent];
class BrnRadioGroupModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnRadioGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnRadioGroupModule, imports: [BrnRadioGroupDirective, BrnRadioComponent], exports: [BrnRadioGroupDirective, BrnRadioComponent] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnRadioGroupModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnRadioGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnRadioGroupImports],
                    exports: [...BrnRadioGroupImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BRN_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, BrnRadioChange, BrnRadioComponent, BrnRadioGroupDirective, BrnRadioGroupImports, BrnRadioGroupModule };
//# sourceMappingURL=spartan-ng-brain-radio-group.mjs.map
