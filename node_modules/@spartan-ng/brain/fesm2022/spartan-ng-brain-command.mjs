import * as i0 from '@angular/core';
import { InjectionToken, inject, TemplateRef, ViewContainerRef, computed, effect, Directive, input, contentChildren, PLATFORM_ID, ElementRef, booleanAttribute, signal, output, HostListener, Optional, Inject, Injector, contentChild, untracked, NgModule } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { DefaultValueAccessor, COMPOSITION_BUFFER_MODE, NG_VALUE_ACCESSOR } from '@angular/forms';
import { startWith } from 'rxjs/operators';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';

const BrnCommandToken = new InjectionToken('BrnCommandToken');
function provideBrnCommand(command) {
    return { provide: BrnCommandToken, useExisting: command };
}
function injectBrnCommand() {
    return inject(BrnCommandToken);
}

class BrnCommandEmptyDirective {
    _templateRef = inject(TemplateRef);
    _viewContainerRef = inject(ViewContainerRef);
    _command = injectBrnCommand();
    /** Determine if the command has any visible items */
    _visible = computed(() => this._command.items().some((item) => item.visible()));
    constructor() {
        effect(() => {
            if (this._visible()) {
                this._viewContainerRef.clear();
            }
            else {
                this._viewContainerRef.createEmbeddedView(this._templateRef);
            }
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandEmptyDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnCommandEmptyDirective, isStandalone: true, selector: "[brnCommandEmpty]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandEmptyDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[brnCommandEmpty]',
                }]
        }], ctorParameters: () => [] });

const BrnCommandItemToken = new InjectionToken('BrnCommandItemToken');
function provideBrnCommandItem(command) {
    return { provide: BrnCommandItemToken, useExisting: command };
}

class BrnCommandGroupDirective {
    static _id = 0;
    /** The id of the command list */
    id = input(`brn-command-group-${BrnCommandGroupDirective._id++}`);
    /** Get the items in the group */
    _items = contentChildren(BrnCommandItemToken, {
        descendants: true,
    });
    /** Determine if there are any visible items in the group */
    visible = computed(() => this._items().some((item) => item.visible()));
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandGroupDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.8", type: BrnCommandGroupDirective, isStandalone: true, selector: "[brnCommandGroup]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "group" }, properties: { "attr.data-hidden": "!visible() ? \"\" : null", "id": "id()" } }, queries: [{ propertyName: "_items", predicate: BrnCommandItemToken, descendants: true, isSignal: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCommandGroup]',
                    standalone: true,
                    host: {
                        role: 'group',
                        '[attr.data-hidden]': '!visible() ? "" : null',
                        '[id]': 'id()',
                    },
                }]
        }] });

class BrnCommandItemDirective {
    static _id = 0;
    _platform = inject(PLATFORM_ID);
    _elementRef = inject(ElementRef);
    /** Access the command component */
    _command = injectBrnCommand();
    /** A unique id for the item */
    id = input(`brn-command-item-${BrnCommandItemDirective._id++}`);
    /** The value this item represents. */
    value = input.required();
    /** Whether the item is disabled. */
    _disabled = input(false, {
        alias: 'disabled',
        transform: booleanAttribute,
    });
    /** Expose disabled as a value - used by the Highlightable interface */
    get disabled() {
        return this._disabled();
    }
    /** Whether the item is initialized, this is to prevent accessing the value-input before the component is initialized.
     * The brn-command-empty directive accesses the value before the component is initialized, which causes an error.
     */
    _initialized = signal(false);
    /** Whether the item is selected. */
    active = signal(false);
    /** Emits when the item is selected. */
    selected = output();
    /** @internal Determine if this item is visible based on the current search query */
    visible = computed(() => {
        return this._command.filter()(this.safeValue(), this._command.search());
    });
    /** @internal Get the value of the item, with check if it has been initialized to avoid errors */
    safeValue = computed(() => {
        if (!this._initialized()) {
            return '';
        }
        return this.value();
    });
    /** @internal Get the display value */
    getLabel() {
        return this.safeValue();
    }
    /** @internal */
    setActiveStyles() {
        this.active.set(true);
        // ensure the item is in view
        if (isPlatformBrowser(this._platform)) {
            this._elementRef.nativeElement.scrollIntoView({ block: 'nearest' });
        }
    }
    /** @internal */
    setInactiveStyles() {
        this.active.set(false);
    }
    onClick() {
        this._command.keyManager.setActiveItem(this);
        this.selected.emit();
    }
    ngOnInit() {
        this._initialized.set(true);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnCommandItemDirective, isStandalone: true, selector: "button[brnCommandItem]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: true, transformFunction: null }, _disabled: { classPropertyName: "_disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { selected: "selected" }, host: { attributes: { "type": "button", "role": "option", "tabIndex": "-1" }, listeners: { "click": "onClick()" }, properties: { "id": "id()", "attr.disabled": "_disabled() ? true : null", "attr.data-value": "value()", "attr.data-hidden": "!visible() ? '' : null", "attr.aria-selected": "active()", "attr.data-selected": "active() ? '' : null" } }, providers: [provideBrnCommandItem(BrnCommandItemDirective)], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'button[brnCommandItem]',
                    standalone: true,
                    providers: [provideBrnCommandItem(BrnCommandItemDirective)],
                    host: {
                        type: 'button',
                        role: 'option',
                        tabIndex: '-1',
                        '[id]': 'id()',
                        '[attr.disabled]': '_disabled() ? true : null',
                        '[attr.data-value]': 'value()',
                        '[attr.data-hidden]': "!visible() ? '' : null",
                        '[attr.aria-selected]': 'active()',
                        '[attr.data-selected]': "active() ? '' : null",
                    },
                }]
        }], propDecorators: { onClick: [{
                type: HostListener,
                args: ['click']
            }] } });

class BrnCommandListDirective {
    static _id = 0;
    /** The id of the command list */
    id = input(`brn-command-list-${BrnCommandListDirective._id++}`);
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandListDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnCommandListDirective, isStandalone: true, selector: "[brnCommandList]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "listbox" }, properties: { "id": "id()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandListDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[brnCommandList]',
                    host: {
                        role: 'listbox',
                        '[id]': 'id()',
                    },
                }]
        }] });

const BrnCommandSearchInputToken = new InjectionToken('BrnCommandSearchInputToken');
function provideBrnCommandSearchInput(command) {
    return { provide: BrnCommandSearchInputToken, useExisting: command };
}

class BrnCommandSearchInputDirective extends DefaultValueAccessor {
    elementRef;
    _command = injectBrnCommand();
    /** The initial value of the search input */
    value = input('');
    /** @internal The mutable value of the search input */
    mutableValue = computed(() => signal(this.value()));
    /** @internal The "real" value of the search input */
    valueState = computed(() => this.mutableValue()());
    /** The id of the active option */
    _activeDescendant = signal(undefined);
    constructor(renderer, elementRef, compositionMode) {
        super(renderer, elementRef, compositionMode);
        this.elementRef = elementRef;
        this._command.keyManager.change
            .pipe(startWith(this._command.keyManager.activeItemIndex), takeUntilDestroyed())
            .subscribe(() => this._activeDescendant.set(this._command.keyManager.activeItem?.id()));
        effect(() => {
            this.elementRef.nativeElement.value = this.valueState();
        });
    }
    /** Listen for changes to the input value */
    onInput() {
        this.mutableValue().set(this.elementRef.nativeElement.value);
    }
    /** Listen for keydown events */
    onKeyDown(event) {
        this._command.keyManager.onKeydown(event);
    }
    /** CONROL VALUE ACCESSOR */
    writeValue(value) {
        super.writeValue(value);
        if (value) {
            this.mutableValue().set(value);
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandSearchInputDirective, deps: [{ token: i0.Renderer2 }, { token: i0.ElementRef }, { token: COMPOSITION_BUFFER_MODE, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnCommandSearchInputDirective, isStandalone: true, selector: "input[brnCommandSearchInput]", inputs: { value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "combobox", "aria-autocomplete": "list" }, listeners: { "keydown": "onKeyDown($event)", "input": "onInput()" }, properties: { "attr.aria-activedescendant": "_activeDescendant()" } }, providers: [
            provideBrnCommandSearchInput(BrnCommandSearchInputDirective),
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: BrnCommandSearchInputDirective,
                multi: true,
            },
        ], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandSearchInputDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[brnCommandSearchInput]',
                    standalone: true,
                    providers: [
                        provideBrnCommandSearchInput(BrnCommandSearchInputDirective),
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: BrnCommandSearchInputDirective,
                            multi: true,
                        },
                    ],
                    host: {
                        role: 'combobox',
                        'aria-autocomplete': 'list',
                        '[attr.aria-activedescendant]': '_activeDescendant()',
                        '(keydown)': 'onKeyDown($event)',
                        '(input)': 'onInput()',
                    },
                }]
        }], ctorParameters: () => [{ type: i0.Renderer2 }, { type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [COMPOSITION_BUFFER_MODE]
                }] }] });

class BrnCommandDirective {
    static _id = 0;
    _platform = inject(PLATFORM_ID);
    _injector = inject(Injector);
    /** The id of the command */
    id = input(`brn-command-${BrnCommandDirective._id++}`);
    /** The default filter function */
    _defaultFilter = (value, search) => value.toLowerCase().includes(search.toLowerCase());
    /** A custom filter function to use when searching. */
    filter = input(this._defaultFilter);
    /** when the selection has changed */
    valueChange = output();
    /** @internal The search query */
    search = computed(() => this._searchInput()?.valueState() ?? '');
    /** Access the search input if present */
    _searchInput = contentChild(BrnCommandSearchInputDirective, {
        descendants: true,
    });
    /** @internal Access all the items within the commmand */
    items = contentChildren(BrnCommandItemToken, {
        descendants: true,
    });
    /** @internal The key manager for managing active descendant */
    keyManager = new ActiveDescendantKeyManager(this.items, this._injector);
    constructor() {
        this.keyManager
            .withVerticalOrientation()
            .withHomeAndEnd()
            .withWrap()
            .skipPredicate((item) => item.disabled || !item.visible());
        // When clearing the search input we also want to reset the active item to the first one
        effect(() => {
            const searchInput = this.search();
            untracked(() => {
                const activeItemIsVisible = this.keyManager.activeItem?.visible();
                if ((searchInput !== undefined && searchInput.length === 0) || !activeItemIsVisible) {
                    this.keyManager.setFirstItemActive();
                }
            });
        });
        this.keyManager.change.pipe(takeUntilDestroyed()).subscribe(() => {
            const value = this.keyManager.activeItem?.safeValue();
            if (value) {
                this.valueChange.emit(value);
            }
        });
    }
    ngAfterViewInit() {
        if (isPlatformBrowser(this._platform) && this.items().length) {
            this.keyManager.setActiveItem(0);
        }
    }
    selectActiveItem() {
        this.keyManager.activeItem?.selected.emit();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.8", type: BrnCommandDirective, isStandalone: true, selector: "[brnCommand]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, filter: { classPropertyName: "filter", publicName: "filter", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { valueChange: "valueChange" }, host: { listeners: { "keydown.enter": "selectActiveItem()" }, properties: { "id": "id()" } }, providers: [provideBrnCommand(BrnCommandDirective)], queries: [{ propertyName: "_searchInput", first: true, predicate: BrnCommandSearchInputDirective, descendants: true, isSignal: true }, { propertyName: "items", predicate: BrnCommandItemToken, descendants: true, isSignal: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCommand]',
                    standalone: true,
                    providers: [provideBrnCommand(BrnCommandDirective)],
                    host: {
                        '[id]': 'id()',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { selectActiveItem: [{
                type: HostListener,
                args: ['keydown.enter']
            }] } });

const BrnCommandImports = [
    BrnCommandEmptyDirective,
    BrnCommandGroupDirective,
    BrnCommandItemDirective,
    BrnCommandListDirective,
    BrnCommandSearchInputDirective,
    BrnCommandDirective,
];
class BrnCommandModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandModule, imports: [BrnCommandEmptyDirective,
            BrnCommandGroupDirective,
            BrnCommandItemDirective,
            BrnCommandListDirective,
            BrnCommandSearchInputDirective,
            BrnCommandDirective], exports: [BrnCommandEmptyDirective,
            BrnCommandGroupDirective,
            BrnCommandItemDirective,
            BrnCommandListDirective,
            BrnCommandSearchInputDirective,
            BrnCommandDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCommandModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnCommandImports],
                    exports: [...BrnCommandImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnCommandDirective, BrnCommandEmptyDirective, BrnCommandGroupDirective, BrnCommandImports, BrnCommandItemDirective, BrnCommandItemToken, BrnCommandListDirective, BrnCommandModule, BrnCommandSearchInputDirective, BrnCommandSearchInputToken, BrnCommandToken, injectBrnCommand, provideBrnCommand, provideBrnCommandItem, provideBrnCommandSearchInput };
//# sourceMappingURL=spartan-ng-brain-command.mjs.map
