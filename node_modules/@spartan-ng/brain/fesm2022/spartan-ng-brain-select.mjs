import * as i0 from '@angular/core';
import { InjectionToken, inject, ElementRef, input, booleanAttribute, computed, signal, Directive, DestroyRef, Injector, viewChild, contentChild, contentChildren, effect, afterNextRender, untracked, ChangeDetectionStrategy, Component, TemplateRef, PLATFORM_ID, numberAttribute, model, NgModule } from '@angular/core';
import { NgTemplateOutlet, isPlatformBrowser } from '@angular/common';
import { takeUntilDestroyed, toSignal, toObservable } from '@angular/core/rxjs-interop';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { Subject, fromEvent, interval, of } from 'rxjs';
import { takeUntil, switchMap, delay, map } from 'rxjs/operators';
import * as i1 from '@spartan-ng/brain/label';
import { BrnLabelDirective } from '@spartan-ng/brain/label';
import { NgControl, NgForm, FormGroupDirective } from '@angular/forms';
import { CdkListboxModule } from '@angular/cdk/listbox';
import * as i1$1 from '@angular/cdk/overlay';
import { CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';
import { provideExposedSideProviderExisting, provideExposesStateProviderExisting } from '@spartan-ng/brain/core';
import { BrnFormFieldControl } from '@spartan-ng/brain/form-field';
import { ErrorStateMatcher, ErrorStateTracker } from '@spartan-ng/brain/forms';

const BrnSelectContentToken = new InjectionToken('BrnSelectContentToken');
function injectBrnSelectContent() {
    return inject(BrnSelectContentToken);
}
function provideBrnSelectContent(select) {
    return { provide: BrnSelectContentToken, useExisting: select };
}

const BrnSelectToken = new InjectionToken('BrnSelectToken');
function injectBrnSelect() {
    return inject(BrnSelectToken);
}
function provideBrnSelect(select) {
    return { provide: BrnSelectToken, useExisting: select };
}

let nextId$1 = 0;
class BrnSelectOptionDirective {
    _select = injectBrnSelect();
    _content = injectBrnSelectContent();
    elementRef = inject(ElementRef);
    id = input(`brn-option-${nextId$1++}`);
    value = input();
    // we use "_disabled" here because disabled is already defined in the Highlightable interface
    _disabled = input(false, {
        alias: 'disabled',
        transform: booleanAttribute,
    });
    get disabled() {
        return this._disabled();
    }
    selected = computed(() => this.value() !== undefined && this._select.isSelected(this.value()));
    _active = signal(false);
    checkedState = computed(() => (this.selected() ? 'checked' : 'unchecked'));
    dir = this._select.dir;
    select() {
        if (this._disabled()) {
            return;
        }
        if (this._select.multiple()) {
            this._select.toggleSelect(this.value());
            return;
        }
        this._select.selectOption(this.value());
    }
    /** Get the label for this element which is required by the FocusableOption interface. */
    getLabel() {
        return this.elementRef.nativeElement.textContent?.trim() ?? '';
    }
    setActiveStyles() {
        this._active.set(true);
        // scroll the option into view if it is not visible
        this.elementRef.nativeElement.scrollIntoView({ block: 'nearest' });
    }
    setInactiveStyles() {
        this._active.set(false);
    }
    activate() {
        if (this._disabled()) {
            return;
        }
        this._content.setActiveOption(this);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectOptionDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnSelectOptionDirective, isStandalone: true, selector: "[brnOption]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, _disabled: { classPropertyName: "_disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "option" }, listeners: { "click": "select()", "mouseenter": "activate()" }, properties: { "id": "id()", "attr.aria-selected": "selected()", "attr.aria-disabled": "_disabled()", "attr.dir": "_select.dir()", "attr.data-active": "_active() ? '' : undefined", "attr.data-disabled": "_disabled() ? '' : undefined" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectOptionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnOption]',
                    standalone: true,
                    host: {
                        role: 'option',
                        '[id]': 'id()',
                        '[attr.aria-selected]': 'selected()',
                        '[attr.aria-disabled]': '_disabled()',
                        '(click)': 'select()',
                        '[attr.dir]': '_select.dir()',
                        '[attr.data-active]': "_active() ? '' : undefined",
                        '[attr.data-disabled]': "_disabled() ? '' : undefined",
                        '(mouseenter)': 'activate()',
                    },
                }]
        }] });

const SCROLLBY_PIXELS = 100;
class BrnSelectScrollUpDirective {
    _el = inject(ElementRef);
    _selectContent = inject(BrnSelectContentComponent);
    _endReached = new Subject();
    _destroyRef = inject(DestroyRef);
    startEmittingEvents() {
        const mouseLeave$ = fromEvent(this._el.nativeElement, 'mouseleave');
        interval(100)
            .pipe(takeUntil(mouseLeave$), takeUntil(this._endReached), takeUntilDestroyed(this._destroyRef))
            .subscribe(() => this._selectContent.moveFocusUp());
    }
    stopEmittingEvents() {
        this._endReached.next(true);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectScrollUpDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSelectScrollUpDirective, isStandalone: true, selector: "[brnSelectScrollUp], brn-select-scroll-up, hlm-select-scroll-up:not(noHlm)", host: { attributes: { "aria-hidden": "true" }, listeners: { "mouseenter": "startEmittingEvents()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectScrollUpDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSelectScrollUp], brn-select-scroll-up, hlm-select-scroll-up:not(noHlm)',
                    standalone: true,
                    host: {
                        'aria-hidden': 'true',
                        '(mouseenter)': 'startEmittingEvents()',
                    },
                }]
        }] });
class BrnSelectScrollDownDirective {
    _el = inject(ElementRef);
    _selectContent = inject(BrnSelectContentComponent);
    _endReached = new Subject();
    _destroyRef = inject(DestroyRef);
    startEmittingEvents() {
        const mouseLeave$ = fromEvent(this._el.nativeElement, 'mouseleave');
        interval(100)
            .pipe(takeUntil(mouseLeave$), takeUntil(this._endReached), takeUntilDestroyed(this._destroyRef))
            .subscribe(() => this._selectContent.moveFocusDown());
    }
    stopEmittingEvents() {
        this._endReached.next(true);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectScrollDownDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSelectScrollDownDirective, isStandalone: true, selector: "[brnSelectScrollDown], brn-select-scroll-down, hlm-select-scroll-down:not(noHlm)", host: { attributes: { "aria-hidden": "true" }, listeners: { "mouseenter": "startEmittingEvents()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectScrollDownDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSelectScrollDown], brn-select-scroll-down, hlm-select-scroll-down:not(noHlm)',
                    standalone: true,
                    host: {
                        'aria-hidden': 'true',
                        '(mouseenter)': 'startEmittingEvents()',
                    },
                }]
        }] });
class BrnSelectContentComponent {
    _elementRef = inject(ElementRef);
    _injector = inject(Injector);
    _select = injectBrnSelect();
    canScrollUp = signal(false);
    canScrollDown = signal(false);
    viewport = viewChild.required('viewport');
    scrollUpBtn = contentChild(BrnSelectScrollUpDirective);
    scrollDownBtn = contentChild(BrnSelectScrollDownDirective);
    _options = contentChildren(BrnSelectOptionDirective, { descendants: true });
    /** @internal */
    keyManager = null;
    constructor() {
        effect(() => {
            this._select.open() && afterNextRender(() => this.updateArrowDisplay(), { injector: this._injector });
        });
    }
    ngAfterContentInit() {
        this.keyManager = new ActiveDescendantKeyManager(this._options, this._injector)
            .withHomeAndEnd()
            .withVerticalOrientation()
            .withTypeAhead()
            .withAllowedModifierKeys(['shiftKey'])
            .withWrap()
            .skipPredicate((option) => option._disabled());
        effect(() => {
            // any time the select is opened, we need to focus the first selected option or the first option
            const open = this._select.open();
            const options = this._options();
            if (!open || !options.length) {
                return;
            }
            untracked(() => {
                const selectedOption = options.find((option) => option.selected());
                if (selectedOption) {
                    this.keyManager?.setActiveItem(selectedOption);
                }
                else {
                    this.keyManager?.setFirstItemActive();
                }
            });
        }, { injector: this._injector });
    }
    updateArrowDisplay() {
        const { scrollTop, scrollHeight, clientHeight } = this.viewport().nativeElement;
        this.canScrollUp.set(scrollTop > 0);
        const maxScroll = scrollHeight - clientHeight;
        this.canScrollDown.set(Math.ceil(scrollTop) < maxScroll);
    }
    handleScroll() {
        this.updateArrowDisplay();
    }
    focusList() {
        this._elementRef.nativeElement.focus();
    }
    moveFocusUp() {
        this.viewport().nativeElement.scrollBy({ top: -SCROLLBY_PIXELS, behavior: 'smooth' });
        if (this.viewport().nativeElement.scrollTop === 0) {
            this.scrollUpBtn()?.stopEmittingEvents();
        }
    }
    moveFocusDown() {
        this.viewport().nativeElement.scrollBy({ top: SCROLLBY_PIXELS, behavior: 'smooth' });
        const viewportSize = this._elementRef.nativeElement.scrollHeight;
        const viewportScrollPosition = this.viewport().nativeElement.scrollTop;
        if (viewportSize + viewportScrollPosition + SCROLLBY_PIXELS >
            this.viewport().nativeElement.scrollHeight + SCROLLBY_PIXELS / 2) {
            this.scrollDownBtn()?.stopEmittingEvents();
        }
    }
    setActiveOption(option) {
        const index = this._options().findIndex((o) => o === option);
        if (index === -1) {
            return;
        }
        this.keyManager?.setActiveItem(index);
    }
    selectActiveItem(event) {
        event.preventDefault();
        const activeOption = this.keyManager?.activeItem;
        if (activeOption) {
            this._select.selectOption(activeOption.value());
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.8", type: BrnSelectContentComponent, isStandalone: true, selector: "brn-select-content, hlm-select-content:not(noHlm)", host: { attributes: { "role": "listbox", "tabindex": "0", "aria-orientation": "vertical" }, listeners: { "keydown": "keyManager?.onKeydown($event)", "keydown.enter": "selectActiveItem($event)", "keydown.space": "selectActiveItem($event)" }, properties: { "attr.aria-multiselectable": "_select.multiple()", "attr.aria-disabled": "_select.disabled() || _select._formDisabled()", "attr.aria-activedescendant": "keyManager?.activeItem?.id()", "attr.aria-labelledBy": "_select.labelId()", "attr.aria-controlledBy": "_select.id() +'--trigger'", "id": "_select.id() + '--content'", "attr.dir": "_select.dir()" } }, providers: [provideBrnSelectContent(BrnSelectContentComponent)], queries: [{ propertyName: "scrollUpBtn", first: true, predicate: BrnSelectScrollUpDirective, descendants: true, isSignal: true }, { propertyName: "scrollDownBtn", first: true, predicate: BrnSelectScrollDownDirective, descendants: true, isSignal: true }, { propertyName: "_options", predicate: BrnSelectOptionDirective, descendants: true, isSignal: true }], viewQueries: [{ propertyName: "viewport", first: true, predicate: ["viewport"], descendants: true, isSignal: true }], ngImport: i0, template: `
		<ng-template #scrollUp>
			<ng-content select="hlm-select-scroll-up" />
			<ng-content select="brnSelectScrollUp" />
		</ng-template>
		<ng-container *ngTemplateOutlet="canScrollUp() && scrollUpBtn() ? scrollUp : null" />
		<div
			data-brn-select-viewport
			#viewport
			(scroll)="handleScroll()"
			style="flex: 1 1 0%;
			position: relative;
			width:100%;
			overflow:auto;
			min-height: 36px;
      padding-bottom: 2px;
      margin-bottom: -2px;"
		>
			<ng-content />
		</div>
		<ng-template #scrollDown>
			<ng-content select="brnSelectScrollDown" />
			<ng-content select="hlm-select-scroll-down" />
		</ng-template>
		<ng-container *ngTemplateOutlet="canScrollDown() && scrollDownBtn() ? scrollDown : null" />
	`, isInline: true, styles: [":host{display:flex;box-sizing:border-box;flex-direction:column;outline:none;pointer-events:auto}[data-brn-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch}[data-brn-select-viewport]::-webkit-scrollbar{display:none}\n"], dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectContentComponent, decorators: [{
            type: Component,
            args: [{ selector: 'brn-select-content, hlm-select-content:not(noHlm)', imports: [NgTemplateOutlet], providers: [provideBrnSelectContent(BrnSelectContentComponent)], changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        role: 'listbox',
                        tabindex: '0',
                        '[attr.aria-multiselectable]': '_select.multiple()',
                        '[attr.aria-disabled]': '_select.disabled() || _select._formDisabled()',
                        'aria-orientation': 'vertical',
                        '[attr.aria-activedescendant]': 'keyManager?.activeItem?.id()',
                        '[attr.aria-labelledBy]': '_select.labelId()',
                        '[attr.aria-controlledBy]': "_select.id() +'--trigger'",
                        '[id]': "_select.id() + '--content'",
                        '[attr.dir]': '_select.dir()',
                        '(keydown)': 'keyManager?.onKeydown($event)',
                        '(keydown.enter)': 'selectActiveItem($event)',
                        '(keydown.space)': 'selectActiveItem($event)',
                    }, template: `
		<ng-template #scrollUp>
			<ng-content select="hlm-select-scroll-up" />
			<ng-content select="brnSelectScrollUp" />
		</ng-template>
		<ng-container *ngTemplateOutlet="canScrollUp() && scrollUpBtn() ? scrollUp : null" />
		<div
			data-brn-select-viewport
			#viewport
			(scroll)="handleScroll()"
			style="flex: 1 1 0%;
			position: relative;
			width:100%;
			overflow:auto;
			min-height: 36px;
      padding-bottom: 2px;
      margin-bottom: -2px;"
		>
			<ng-content />
		</div>
		<ng-template #scrollDown>
			<ng-content select="brnSelectScrollDown" />
			<ng-content select="hlm-select-scroll-down" />
		</ng-template>
		<ng-container *ngTemplateOutlet="canScrollDown() && scrollDownBtn() ? scrollDown : null" />
	`, styles: [":host{display:flex;box-sizing:border-box;flex-direction:column;outline:none;pointer-events:auto}[data-brn-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch}[data-brn-select-viewport]::-webkit-scrollbar{display:none}\n"] }]
        }], ctorParameters: () => [] });

class BrnSelectGroupDirective {
    labelledBy = signal('');
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectGroupDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSelectGroupDirective, isStandalone: true, selector: "[brnSelectGroup]", host: { attributes: { "role": "group" }, properties: { "attr.aria-labelledby": "labelledBy()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSelectGroup]',
                    standalone: true,
                    host: {
                        role: 'group',
                        '[attr.aria-labelledby]': 'labelledBy()',
                    },
                }]
        }] });

class BrnSelectLabelDirective {
    _group = inject(BrnSelectGroupDirective, { optional: true });
    _label = inject(BrnLabelDirective, { host: true });
    constructor() {
        this._group?.labelledBy.set(this._label.id());
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectLabelDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSelectLabelDirective, isStandalone: true, selector: "[brnSelectLabel]", hostDirectives: [{ directive: i1.BrnLabelDirective }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectLabelDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSelectLabel]',
                    hostDirectives: [BrnLabelDirective],
                    standalone: true,
                }]
        }], ctorParameters: () => [] });

class BrnSelectPlaceholderDirective {
    /** @internale */
    templateRef = inject(TemplateRef);
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectPlaceholderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSelectPlaceholderDirective, isStandalone: true, selector: "[brnSelectPlaceholder], [hlmSelectPlaceholder]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectPlaceholderDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[brnSelectPlaceholder], [hlmSelectPlaceholder]',
                }]
        }] });

class BrnSelectTriggerDirective {
    _elementRef = inject(ElementRef);
    _select = injectBrnSelect();
    _ngControl = inject(NgControl, { optional: true });
    _platform = inject(PLATFORM_ID);
    _triggerId = computed(() => `${this._select.id()}--trigger`);
    _contentId = computed(() => `${this._select.id()}--content`);
    _disabled = computed(() => this._select.disabled() || this._select._formDisabled());
    _labelledBy = computed(() => {
        const value = this._select.value();
        if (Array.isArray(value) && value.length > 0) {
            return `${this._select.labelId()} ${this._select.id()}--value`;
        }
        return this._select.labelId();
    });
    _resizeObserver;
    constructor() {
        this._select.trigger.set(this);
    }
    ngAfterViewInit() {
        this._select.triggerWidth.set(this._elementRef.nativeElement.offsetWidth);
        // if we are on the client, listen for element resize events
        if (isPlatformBrowser(this._platform)) {
            this._resizeObserver = new ResizeObserver(() => this._select.triggerWidth.set(this._elementRef.nativeElement.offsetWidth));
            this._resizeObserver.observe(this._elementRef.nativeElement);
        }
    }
    ngOnDestroy() {
        this._resizeObserver?.disconnect();
    }
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSelectTriggerDirective, isStandalone: true, selector: "[brnSelectTrigger]", host: { attributes: { "type": "button", "role": "combobox", "aria-autocomplete": "none" }, listeners: { "keydown.ArrowDown": "_select.show()" }, properties: { "attr.id": "_triggerId()", "disabled": "_disabled()", "attr.aria-expanded": "_select.open()", "attr.aria-controls": "_contentId()", "attr.aria-labelledBy": "_labelledBy()", "attr.dir": "_select.dir()", "class.ng-invalid": "_ngControl?.invalid || null", "class.ng-dirty": "_ngControl?.dirty || null", "class.ng-valid": "_ngControl?.valid || null", "class.ng-touched": "_ngControl?.touched || null", "class.ng-untouched": "_ngControl?.untouched || null", "class.ng-pristine": "_ngControl?.pristine || null" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSelectTrigger]',
                    standalone: true,
                    host: {
                        type: 'button',
                        role: 'combobox',
                        '[attr.id]': '_triggerId()',
                        '[disabled]': '_disabled()',
                        '[attr.aria-expanded]': '_select.open()',
                        '[attr.aria-controls]': '_contentId()',
                        '[attr.aria-labelledBy]': '_labelledBy()',
                        'aria-autocomplete': 'none',
                        '[attr.dir]': '_select.dir()',
                        '[class.ng-invalid]': '_ngControl?.invalid || null',
                        '[class.ng-dirty]': '_ngControl?.dirty || null',
                        '[class.ng-valid]': '_ngControl?.valid || null',
                        '[class.ng-touched]': '_ngControl?.touched || null',
                        '[class.ng-untouched]': '_ngControl?.untouched || null',
                        '[class.ng-pristine]': '_ngControl?.pristine || null',
                        '(keydown.ArrowDown)': '_select.show()',
                    },
                }]
        }], ctorParameters: () => [] });

class BrnSelectValueDirective {
    /** @internale */
    templateRef = inject(TemplateRef);
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectValueDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSelectValueDirective, isStandalone: true, selector: "[brnSelectValue], [hlmSelectValue]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectValueDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[brnSelectValue], [hlmSelectValue]',
                }]
        }] });

class BrnSelectValueComponent {
    _select = injectBrnSelect();
    id = computed(() => `${this._select.id()}--value`);
    placeholder = computed(() => this._select.placeholder());
    _showPlaceholder = computed(() => this.value() === null || this.value() === undefined || this.value() === '');
    /** Allow a custom value template */
    customValueTemplate = contentChild(BrnSelectValueDirective, { descendants: true });
    customPlaceholderTemplate = contentChild(BrnSelectPlaceholderDirective, { descendants: true });
    value = computed(() => {
        const value = this._values();
        if (value.length === 0) {
            return null;
        }
        // remove any selected values that are not in the options list
        const existingOptions = value.filter((val) => this._select.options().some((option) => this._select.compareWith()(option.value(), val)));
        const selectedOption = existingOptions.map((val) => this._select.options().find((option) => this._select.compareWith()(option.value(), val)));
        if (selectedOption.length === 0) {
            return null;
        }
        const selectedLabels = selectedOption.map((option) => option?.getLabel());
        if (this._select.dir() === 'rtl') {
            selectedLabels.reverse();
        }
        return this.transformFn()(selectedLabels);
    });
    /** Normalize the values as an array */
    _values = computed(() => Array.isArray(this._select.value()) ? this._select.value() : [this._select.value()]);
    transformFn = input((values) => (values ?? []).join(', '));
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectValueComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.8", type: BrnSelectValueComponent, isStandalone: true, selector: "brn-select-value, hlm-select-value", inputs: { transformFn: { classPropertyName: "transformFn", publicName: "transformFn", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "id": "id()", "attr.data-placeholder": "_showPlaceholder() ? \"\" : null" } }, queries: [{ propertyName: "customValueTemplate", first: true, predicate: BrnSelectValueDirective, descendants: true, isSignal: true }, { propertyName: "customPlaceholderTemplate", first: true, predicate: BrnSelectPlaceholderDirective, descendants: true, isSignal: true }], ngImport: i0, template: `
		@if (_showPlaceholder()) {
			<ng-container [ngTemplateOutlet]="customPlaceholderTemplate()?.templateRef ?? defaultPlaceholderTemplate" />
		} @else {
			<ng-container
				[ngTemplateOutlet]="customValueTemplate()?.templateRef ?? defaultValueTemplate"
				[ngTemplateOutletContext]="{ $implicit: _select.value() }"
			/>
		}

		<ng-template #defaultValueTemplate>{{ value() }}</ng-template>
		<ng-template #defaultPlaceholderTemplate>{{ placeholder() }}</ng-template>
	`, isInline: true, styles: [":host{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1;white-space:nowrap;pointer-events:none}\n"], dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectValueComponent, decorators: [{
            type: Component,
            args: [{ selector: 'brn-select-value, hlm-select-value', imports: [NgTemplateOutlet], template: `
		@if (_showPlaceholder()) {
			<ng-container [ngTemplateOutlet]="customPlaceholderTemplate()?.templateRef ?? defaultPlaceholderTemplate" />
		} @else {
			<ng-container
				[ngTemplateOutlet]="customValueTemplate()?.templateRef ?? defaultValueTemplate"
				[ngTemplateOutletContext]="{ $implicit: _select.value() }"
			/>
		}

		<ng-template #defaultValueTemplate>{{ value() }}</ng-template>
		<ng-template #defaultPlaceholderTemplate>{{ placeholder() }}</ng-template>
	`, host: {
                        '[id]': 'id()',
                        '[attr.data-placeholder]': '_showPlaceholder() ? "" : null',
                    }, changeDetection: ChangeDetectionStrategy.OnPush, styles: [":host{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1;white-space:nowrap;pointer-events:none}\n"] }]
        }] });

let nextId = 0;
class BrnSelectComponent {
    _defaultErrorStateMatcher = inject(ErrorStateMatcher);
    _parentForm = inject(NgForm, { optional: true });
    _injector = inject(Injector);
    _parentFormGroup = inject(FormGroupDirective, { optional: true });
    ngControl = inject(NgControl, { optional: true, self: true });
    id = input(`brn-select-${nextId++}`);
    multiple = input(false, {
        transform: booleanAttribute,
    });
    placeholder = input('');
    disabled = input(false, {
        transform: booleanAttribute,
    });
    dir = input('ltr');
    closeDelay = input(100, {
        transform: numberAttribute,
    });
    open = model(false);
    value = model();
    compareWith = input((o1, o2) => o1 === o2);
    _formDisabled = signal(false);
    /** Label provided by the consumer. */
    selectLabel = contentChild(BrnLabelDirective, { descendants: false });
    /** Overlay pane containing the options. */
    selectContent = contentChild.required(BrnSelectContentComponent);
    /** @internal */
    options = contentChildren(BrnSelectOptionDirective, { descendants: true });
    /** @internal Derive the selected options to filter out the unselected options */
    selectedOptions = computed(() => this.options().filter((option) => option.selected()));
    /** Overlay pane containing the options. */
    _overlayDir = viewChild.required(CdkConnectedOverlay);
    trigger = signal(null);
    triggerWidth = signal(0);
    _delayedExpanded = toSignal(toObservable(this.open).pipe(switchMap((expanded) => (!expanded ? of(expanded).pipe(delay(this.closeDelay())) : of(expanded))), takeUntilDestroyed()), { initialValue: false });
    state = computed(() => (this.open() ? 'open' : 'closed'));
    _positionChanges$ = new Subject();
    side = toSignal(this._positionChanges$.pipe(map((change) => 
    // todo: better translation or adjusting hlm to take that into account
    change.connectionPair.originY === 'center'
        ? change.connectionPair.originX === 'start'
            ? 'left'
            : 'right'
        : change.connectionPair.originY)), { initialValue: 'bottom' });
    labelId = computed(() => this.selectLabel()?.id ?? `${this.id()}--label`);
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    _onChange = () => { };
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    _onTouched = () => { };
    /*
     * This position config ensures that the top "start" corner of the overlay
     * is aligned with with the top "start" of the origin by default (overlapping
     * the trigger completely). If the panel cannot fit below the trigger, it
     * will fall back to a position above the trigger.
     */
    _positions = [
        {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top',
        },
        {
            originX: 'end',
            originY: 'bottom',
            overlayX: 'end',
            overlayY: 'top',
        },
        {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom',
        },
        {
            originX: 'end',
            originY: 'top',
            overlayX: 'end',
            overlayY: 'bottom',
        },
    ];
    errorStateTracker;
    errorState = computed(() => this.errorStateTracker.errorState());
    constructor() {
        if (this.ngControl !== null) {
            this.ngControl.valueAccessor = this;
        }
        this.errorStateTracker = new ErrorStateTracker(this._defaultErrorStateMatcher, this.ngControl, this._parentFormGroup, this._parentForm);
    }
    ngDoCheck() {
        this.errorStateTracker.updateErrorState();
    }
    toggle() {
        if (this.open()) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    show() {
        if (this.open() || this.disabled() || this._formDisabled() || this.options()?.length == 0) {
            return;
        }
        this.open.set(true);
        afterNextRender(() => this.selectContent().focusList(), { injector: this._injector });
    }
    hide() {
        if (!this.open())
            return;
        this.open.set(false);
        this._onTouched();
        // restore focus to the trigger
        this.trigger()?.focus();
    }
    writeValue(value) {
        this.value.set(value);
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this._formDisabled.set(isDisabled);
    }
    selectOption(value) {
        // if this is a multiple select we need to add the value to the array
        if (this.multiple()) {
            const currentValue = this.value();
            const newValue = currentValue ? [...currentValue, value] : [value];
            this.value.set(newValue);
        }
        else {
            this.value.set(value);
        }
        this._onChange?.(this.value());
        // if this is single select close the dropdown
        if (!this.multiple()) {
            this.hide();
        }
    }
    deselectOption(value) {
        if (this.multiple()) {
            const currentValue = this.value();
            this.value.set(currentValue.filter((val) => !this.compareWith()(val, value)));
        }
        else {
            this.value.set(null);
        }
        this._onChange?.(this.value());
    }
    toggleSelect(value) {
        if (this.isSelected(value)) {
            this.deselectOption(value);
        }
        else {
            this.selectOption(value);
        }
    }
    isSelected(value) {
        const selection = this.value();
        if (Array.isArray(selection)) {
            return selection.some((val) => this.compareWith()(val, value));
        }
        else if (value !== undefined) {
            return this.compareWith()(selection, value);
        }
        return false;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.8", type: BrnSelectComponent, isStandalone: true, selector: "brn-select, hlm-select", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, multiple: { classPropertyName: "multiple", publicName: "multiple", isSignal: true, isRequired: false, transformFunction: null }, placeholder: { classPropertyName: "placeholder", publicName: "placeholder", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, dir: { classPropertyName: "dir", publicName: "dir", isSignal: true, isRequired: false, transformFunction: null }, closeDelay: { classPropertyName: "closeDelay", publicName: "closeDelay", isSignal: true, isRequired: false, transformFunction: null }, open: { classPropertyName: "open", publicName: "open", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, compareWith: { classPropertyName: "compareWith", publicName: "compareWith", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { open: "openChange", value: "valueChange" }, providers: [
            provideExposedSideProviderExisting((() => BrnSelectComponent)),
            provideExposesStateProviderExisting((() => BrnSelectComponent)),
            provideBrnSelect(BrnSelectComponent),
            {
                provide: BrnFormFieldControl,
                useExisting: BrnSelectComponent,
            },
        ], queries: [{ propertyName: "selectLabel", first: true, predicate: BrnLabelDirective, isSignal: true }, { propertyName: "selectContent", first: true, predicate: BrnSelectContentComponent, descendants: true, isSignal: true }, { propertyName: "options", predicate: BrnSelectOptionDirective, descendants: true, isSignal: true }], viewQueries: [{ propertyName: "_overlayDir", first: true, predicate: CdkConnectedOverlay, descendants: true, isSignal: true }], ngImport: i0, template: `
		@if (!selectLabel() && placeholder()) {
			<label class="hidden" [attr.id]="labelId()">{{ placeholder() }}</label>
		} @else {
			<ng-content select="label[hlmLabel],label[brnLabel]" />
		}

		<div cdk-overlay-origin (click)="toggle()" #trigger="cdkOverlayOrigin">
			<ng-content select="hlm-select-trigger,[brnSelectTrigger]" />
		</div>

		<ng-template
			cdk-connected-overlay
			cdkConnectedOverlayLockPosition
			cdkConnectedOverlayHasBackdrop
			cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
			[cdkConnectedOverlayOrigin]="trigger"
			[cdkConnectedOverlayOpen]="_delayedExpanded()"
			[cdkConnectedOverlayPositions]="_positions"
			[cdkConnectedOverlayWidth]="triggerWidth() > 0 ? triggerWidth() : 'auto'"
			(backdropClick)="hide()"
			(detach)="hide()"
			(positionChange)="_positionChanges$.next($event)"
		>
			<ng-content />
		</ng-template>
	`, isInline: true, dependencies: [{ kind: "ngmodule", type: OverlayModule }, { kind: "directive", type: i1$1.CdkConnectedOverlay, selector: "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]", inputs: ["cdkConnectedOverlayOrigin", "cdkConnectedOverlayPositions", "cdkConnectedOverlayPositionStrategy", "cdkConnectedOverlayOffsetX", "cdkConnectedOverlayOffsetY", "cdkConnectedOverlayWidth", "cdkConnectedOverlayHeight", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayMinHeight", "cdkConnectedOverlayBackdropClass", "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayViewportMargin", "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOpen", "cdkConnectedOverlayDisableClose", "cdkConnectedOverlayTransformOriginOn", "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayLockPosition", "cdkConnectedOverlayFlexibleDimensions", "cdkConnectedOverlayGrowAfterOpen", "cdkConnectedOverlayPush", "cdkConnectedOverlayDisposeOnNavigation"], outputs: ["backdropClick", "positionChange", "attach", "detach", "overlayKeydown", "overlayOutsideClick"], exportAs: ["cdkConnectedOverlay"] }, { kind: "directive", type: i1$1.CdkOverlayOrigin, selector: "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]", exportAs: ["cdkOverlayOrigin"] }, { kind: "ngmodule", type: CdkListboxModule }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-select, hlm-select',
                    imports: [OverlayModule, CdkListboxModule],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        provideExposedSideProviderExisting((() => BrnSelectComponent)),
                        provideExposesStateProviderExisting((() => BrnSelectComponent)),
                        provideBrnSelect(BrnSelectComponent),
                        {
                            provide: BrnFormFieldControl,
                            useExisting: BrnSelectComponent,
                        },
                    ],
                    template: `
		@if (!selectLabel() && placeholder()) {
			<label class="hidden" [attr.id]="labelId()">{{ placeholder() }}</label>
		} @else {
			<ng-content select="label[hlmLabel],label[brnLabel]" />
		}

		<div cdk-overlay-origin (click)="toggle()" #trigger="cdkOverlayOrigin">
			<ng-content select="hlm-select-trigger,[brnSelectTrigger]" />
		</div>

		<ng-template
			cdk-connected-overlay
			cdkConnectedOverlayLockPosition
			cdkConnectedOverlayHasBackdrop
			cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
			[cdkConnectedOverlayOrigin]="trigger"
			[cdkConnectedOverlayOpen]="_delayedExpanded()"
			[cdkConnectedOverlayPositions]="_positions"
			[cdkConnectedOverlayWidth]="triggerWidth() > 0 ? triggerWidth() : 'auto'"
			(backdropClick)="hide()"
			(detach)="hide()"
			(positionChange)="_positionChanges$.next($event)"
		>
			<ng-content />
		</ng-template>
	`,
                }]
        }], ctorParameters: () => [] });

const BrnSelectImports = [
    BrnSelectComponent,
    BrnSelectContentComponent,
    BrnSelectTriggerDirective,
    BrnSelectOptionDirective,
    BrnSelectValueComponent,
    BrnSelectScrollDownDirective,
    BrnSelectScrollUpDirective,
    BrnSelectGroupDirective,
    BrnSelectLabelDirective,
    BrnSelectValueDirective,
    BrnSelectPlaceholderDirective,
];
class BrnSelectModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectModule, imports: [BrnSelectComponent,
            BrnSelectContentComponent,
            BrnSelectTriggerDirective,
            BrnSelectOptionDirective,
            BrnSelectValueComponent,
            BrnSelectScrollDownDirective,
            BrnSelectScrollUpDirective,
            BrnSelectGroupDirective,
            BrnSelectLabelDirective,
            BrnSelectValueDirective,
            BrnSelectPlaceholderDirective], exports: [BrnSelectComponent,
            BrnSelectContentComponent,
            BrnSelectTriggerDirective,
            BrnSelectOptionDirective,
            BrnSelectValueComponent,
            BrnSelectScrollDownDirective,
            BrnSelectScrollUpDirective,
            BrnSelectGroupDirective,
            BrnSelectLabelDirective,
            BrnSelectValueDirective,
            BrnSelectPlaceholderDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectModule, imports: [BrnSelectComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSelectModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnSelectImports],
                    exports: [...BrnSelectImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnSelectComponent, BrnSelectContentComponent, BrnSelectGroupDirective, BrnSelectImports, BrnSelectLabelDirective, BrnSelectModule, BrnSelectOptionDirective, BrnSelectPlaceholderDirective, BrnSelectScrollDownDirective, BrnSelectScrollUpDirective, BrnSelectTriggerDirective, BrnSelectValueComponent, BrnSelectValueDirective };
//# sourceMappingURL=spartan-ng-brain-select.mjs.map
