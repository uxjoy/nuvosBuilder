import * as i0 from '@angular/core';
import { InjectionToken, inject, Directive, ElementRef, PLATFORM_ID, computed, HostListener, TemplateRef, ViewContainerRef, effect, ChangeDetectorRef, model, input, numberAttribute, booleanAttribute, linkedSignal, signal } from '@angular/core';
import { DOCUMENT, isPlatformServer } from '@angular/common';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent } from 'rxjs';
import { switchMap, takeUntil } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR } from '@angular/forms';

const BrnSliderToken = new InjectionToken('BrnSliderToken');
function provideBrnSlider(slider) {
    return { provide: BrnSliderToken, useExisting: slider };
}
function injectBrnSlider() {
    return inject(BrnSliderToken);
}

class BrnSliderRangeDirective {
    /** Access the slider */
    slider = injectBrnSlider();
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSliderRangeDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSliderRangeDirective, isStandalone: true, selector: "[brnSliderRange]", host: { properties: { "attr.data-disabled": "slider.disabled()", "style.width.%": "slider.percentage()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSliderRangeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSliderRange]',
                    host: {
                        '[attr.data-disabled]': 'slider.disabled()',
                        '[style.width.%]': 'slider.percentage()',
                    },
                }]
        }] });

class BrnSliderThumbDirective {
    slider = injectBrnSlider();
    _document = inject(DOCUMENT);
    _elementRef = inject(ElementRef);
    _platform = inject(PLATFORM_ID);
    /**
     * Offsets the thumb centre point while sliding to ensure it remains
     * within the bounds of the slider when reaching the edges.
     * Based on https://github.com/radix-ui/primitives/blob/main/packages/react/slider/src/slider.tsx
     */
    thumbOffset = computed(() => {
        // we can't compute the offset on the server
        if (isPlatformServer(this._platform)) {
            return this.slider.percentage() + '%';
        }
        const halfWidth = this._elementRef.nativeElement.offsetWidth / 2;
        const offset = this.linearScale([0, 50], [0, halfWidth]);
        const thumbInBoundsOffset = halfWidth - offset(this.slider.percentage());
        const percent = this.slider.percentage();
        return `calc(${percent}% + ${thumbInBoundsOffset}px)`;
    });
    constructor() {
        const mousedown = fromEvent(this._elementRef.nativeElement, 'pointerdown');
        const mouseup = fromEvent(this._document, 'pointerup');
        const mousemove = fromEvent(this._document, 'pointermove');
        // Listen for mousedown events on the slider thumb
        mousedown
            .pipe(switchMap(() => mousemove.pipe(takeUntil(mouseup))), takeUntilDestroyed())
            .subscribe(this.dragThumb.bind(this));
    }
    /** @internal */
    dragThumb(event) {
        if (this.slider.disabled()) {
            return;
        }
        const rect = this.slider.track()?.elementRef.nativeElement.getBoundingClientRect();
        if (!rect) {
            return;
        }
        const percentage = (event.clientX - rect.left) / rect.width;
        this.slider.setValue(this.slider.min() + (this.slider.max() - this.slider.min()) * Math.max(0, Math.min(1, percentage)));
    }
    /**
     * Handle keyboard events.
     * @param event
     */
    handleKeydown(event) {
        const dir = getComputedStyle(this._elementRef.nativeElement).direction;
        let multiplier = event.shiftKey ? 10 : 1;
        const value = this.slider.value();
        // if the slider is RTL, flip the multiplier
        if (dir === 'rtl') {
            multiplier = event.shiftKey ? -10 : -1;
        }
        switch (event.key) {
            case 'ArrowLeft':
                this.slider.setValue(Math.max(value - this.slider.step() * multiplier, this.slider.min()));
                event.preventDefault();
                break;
            case 'ArrowRight':
                this.slider.setValue(Math.min(value + this.slider.step() * multiplier, this.slider.max()));
                event.preventDefault();
                break;
            case 'Home':
                this.slider.setValue(this.slider.min());
                event.preventDefault();
                break;
            case 'End':
                this.slider.setValue(this.slider.max());
                event.preventDefault();
                break;
        }
    }
    linearScale(input, output) {
        return (value) => {
            if (input[0] === input[1] || output[0] === output[1])
                return output[0];
            const ratio = (output[1] - output[0]) / (input[1] - input[0]);
            return output[0] + ratio * (value - input[0]);
        };
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSliderThumbDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSliderThumbDirective, isStandalone: true, selector: "[brnSliderThumb]", host: { attributes: { "role": "slider" }, listeners: { "keydown": "handleKeydown($event)" }, properties: { "attr.aria-valuenow": "slider.value()", "attr.aria-valuemin": "slider.min()", "attr.aria-valuemax": "slider.max()", "attr.tabindex": "slider.disabled() ? -1 : 0", "attr.data-disabled": "slider.disabled()", "style.inset-inline-start": "thumbOffset()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSliderThumbDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSliderThumb]',
                    host: {
                        role: 'slider',
                        '[attr.aria-valuenow]': 'slider.value()',
                        '[attr.aria-valuemin]': 'slider.min()',
                        '[attr.aria-valuemax]': 'slider.max()',
                        '[attr.tabindex]': 'slider.disabled() ? -1 : 0',
                        '[attr.data-disabled]': 'slider.disabled()',
                        '[style.inset-inline-start]': 'thumbOffset()',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { handleKeydown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

class BrnSliderTickDirective {
    _slider = injectBrnSlider();
    _templateRef = inject(TemplateRef);
    _viewContainer = inject(ViewContainerRef);
    _ticks = [];
    constructor() {
        effect(() => {
            const ticks = this._slider.ticks();
            // remove any existing ticks
            this._ticks.forEach((tick) => this._viewContainer.remove(this._viewContainer.indexOf(tick)));
            // create new ticks
            this._ticks = [];
            ticks.forEach((tick, index) => {
                const view = this._viewContainer.createEmbeddedView(this._templateRef, {
                    $implicit: tick,
                    index,
                    position: (index / (ticks.length - 1)) * 100,
                });
                this._ticks.push(view);
            });
        });
    }
    ngOnDestroy() {
        this._ticks.forEach((tick) => this._viewContainer.remove(this._viewContainer.indexOf(tick)));
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSliderTickDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSliderTickDirective, isStandalone: true, selector: "[brnSliderTick]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSliderTickDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSliderTick]',
                }]
        }], ctorParameters: () => [] });

const BrnSliderTrackToken = new InjectionToken('BrnSliderTrackToken');
function provideBrnSliderTrack(slider) {
    return { provide: BrnSliderTrackToken, useExisting: slider };
}
function injectBrnSliderTrack() {
    return inject(BrnSliderTrackToken);
}

class BrnSliderTrackDirective {
    /** Access the slider */
    slider = injectBrnSlider();
    /** @internal Access the slider track */
    elementRef = inject(ElementRef);
    constructor() {
        this.slider.track.set(this);
    }
    moveThumbToPoint(event) {
        if (this.slider.disabled()) {
            return;
        }
        const position = event.clientX;
        const rect = this.elementRef.nativeElement.getBoundingClientRect();
        const percentage = (position - rect.left) / rect.width;
        // update the value based on the position
        this.slider.setValue(this.slider.min() + (this.slider.max() - this.slider.min()) * percentage);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSliderTrackDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnSliderTrackDirective, isStandalone: true, selector: "[brnSliderTrack]", host: { listeners: { "mousedown": "moveThumbToPoint($event)" }, properties: { "attr.data-disabled": "slider.disabled()" } }, providers: [provideBrnSliderTrack(BrnSliderTrackDirective)], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSliderTrackDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSliderTrack]',
                    providers: [provideBrnSliderTrack(BrnSliderTrackDirective)],
                    host: {
                        '[attr.data-disabled]': 'slider.disabled()',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { moveThumbToPoint: [{
                type: HostListener,
                args: ['mousedown', ['$event']]
            }] } });

class BrnSliderDirective {
    _changeDetectorRef = inject(ChangeDetectorRef);
    _elementRef = inject(ElementRef);
    value = model(0);
    min = input(0, {
        transform: numberAttribute,
    });
    max = input(100, {
        transform: numberAttribute,
    });
    step = input(1, {
        transform: numberAttribute,
    });
    _disabled = input(false, {
        alias: 'disabled',
        transform: booleanAttribute,
    });
    /** Whether we should show tick marks */
    showTicks = input(false, {
        transform: booleanAttribute,
    });
    /** @internal */
    ticks = computed(() => {
        const value = this.value();
        if (!this.showTicks()) {
            return [];
        }
        let numActive = Math.max(Math.floor((value - this.min()) / this.step()), 0);
        let numInactive = Math.max(Math.floor((this.max() - value) / this.step()), 0);
        const direction = getComputedStyle(this._elementRef.nativeElement).direction;
        direction === 'rtl' ? numInactive++ : numActive++;
        return Array(numActive).fill(true).concat(Array(numInactive).fill(false));
    });
    /** @internal */
    disabled = linkedSignal(() => this._disabled());
    /** @internal */
    percentage = computed(() => ((this.value() - this.min()) / (this.max() - this.min())) * 100);
    /** @internal Store the on change callback */
    _onChange;
    /** @internal Store the on touched callback */
    _onTouched;
    /** @internal Store the track */
    track = signal(null);
    ngOnInit() {
        // ensure the value is within the min and max range
        if (this.value() < this.min()) {
            this.value.set(this.min());
        }
        if (this.value() > this.max()) {
            this.value.set(this.max());
        }
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled.set(isDisabled);
    }
    writeValue(value) {
        const clampedValue = clamp(value, [this.min(), this.max()]);
        this.value.set(clampedValue);
        if (value !== clampedValue) {
            this._onChange?.(clampedValue);
        }
        this._changeDetectorRef.detectChanges();
    }
    setValue(value) {
        const decimalCount = getDecimalCount(this.step());
        const snapToStep = roundValue(Math.round((value - this.min()) / this.step()) * this.step() + this.min(), decimalCount);
        value = clamp(snapToStep, [this.min(), this.max()]);
        this.value.set(value);
        this._onChange?.(value);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSliderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnSliderDirective, isStandalone: true, selector: "[brnSlider]", inputs: { value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, min: { classPropertyName: "min", publicName: "min", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "max", isSignal: true, isRequired: false, transformFunction: null }, step: { classPropertyName: "step", publicName: "step", isSignal: true, isRequired: false, transformFunction: null }, _disabled: { classPropertyName: "_disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, showTicks: { classPropertyName: "showTicks", publicName: "showTicks", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { value: "valueChange" }, host: { attributes: { "aria-orientation": "horizontal" }, listeners: { "focusout": "_onTouched?.()" } }, providers: [
            provideBrnSlider(BrnSliderDirective),
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: BrnSliderDirective,
                multi: true,
            },
        ], exportAs: ["brnSlider"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnSliderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnSlider]',
                    exportAs: 'brnSlider',
                    providers: [
                        provideBrnSlider(BrnSliderDirective),
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: BrnSliderDirective,
                            multi: true,
                        },
                    ],
                    host: {
                        'aria-orientation': 'horizontal',
                        '(focusout)': '_onTouched?.()',
                    },
                }]
        }] });
function roundValue(value, decimalCount) {
    const rounder = Math.pow(10, decimalCount);
    return Math.round(value * rounder) / rounder;
}
function getDecimalCount(value) {
    return (String(value).split('.')[1] || '').length;
}
function clamp(value, [min, max]) {
    return Math.min(max, Math.max(min, value));
}

const BrnSliderImports = [
    BrnSliderDirective,
    BrnSliderTrackDirective,
    BrnSliderThumbDirective,
    BrnSliderRangeDirective,
    BrnSliderTickDirective,
];

/**
 * Generated bundle index. Do not edit.
 */

export { BrnSliderDirective, BrnSliderImports, BrnSliderRangeDirective, BrnSliderThumbDirective, BrnSliderTickDirective, BrnSliderTrackDirective, injectBrnSlider, provideBrnSlider };
//# sourceMappingURL=spartan-ng-brain-slider.mjs.map
