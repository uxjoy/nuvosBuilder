import * as i0 from '@angular/core';
import { inject, TemplateRef, Directive, NgZone, signal, Injectable, ViewContainerRef, ElementRef, input, computed, effect, untracked, contentChild, Component, NgModule } from '@angular/core';
import { FocusMonitor } from '@angular/cdk/a11y';
import { Overlay, OverlayPositionBuilder } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { toSignal } from '@angular/core/rxjs-interop';
import { brnZoneOptimized, provideExposedSideProviderExisting, provideExposesStateProviderExisting } from '@spartan-ng/brain/core';
import { merge, fromEvent, Subject, BehaviorSubject, of } from 'rxjs';
import { map, filter, distinctUntilChanged, takeUntil, switchMap, tap, delay, share } from 'rxjs/operators';

function movedOut({ currentTarget, relatedTarget }) {
    return !isElement(relatedTarget) || !isElement(currentTarget) || !currentTarget.contains(relatedTarget);
}
function isElement(node) {
    return !!node && 'nodeType' in node && node.nodeType === Node.ELEMENT_NODE;
}
const createHoverObservable = (nativeElement, zone, destroyed$) => {
    return merge(fromEvent(nativeElement, 'mouseenter').pipe(map(() => true)), fromEvent(nativeElement, 'mouseleave').pipe(map(() => false)), 
    // Hello, Safari
    fromEvent(nativeElement, 'mouseout').pipe(filter(movedOut), map(() => false)), 
    /**
     * NOTE: onmouseout events don't trigger when objects move under mouse in Safari
     * https://bugs.webkit.org/show_bug.cgi?id=4117
     */
    fromEvent(nativeElement, 'transitionend').pipe(map(() => nativeElement.matches(':hover')))).pipe(distinctUntilChanged(), brnZoneOptimized(zone), takeUntil(destroyed$));
};

class BrnHoverCardContentDirective {
    _contentService = inject(BrnHoverCardContentService);
    state = this._contentService.state;
    side = this._contentService.side;
    template = inject(TemplateRef);
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardContentDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnHoverCardContentDirective, isStandalone: true, selector: "[brnHoverCardContent]", providers: [
            provideExposedSideProviderExisting((() => BrnHoverCardContentDirective)),
            provideExposesStateProviderExisting((() => BrnHoverCardContentDirective)),
        ], exportAs: ["brnHoverCardContent"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardContentDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnHoverCardContent]',
                    standalone: true,
                    exportAs: 'brnHoverCardContent',
                    providers: [
                        provideExposedSideProviderExisting((() => BrnHoverCardContentDirective)),
                        provideExposesStateProviderExisting((() => BrnHoverCardContentDirective)),
                    ],
                }]
        }] });
const topFirstPositions = [
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
    },
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
    },
];
const bottomFirstPositions = [
    {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
    },
    {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom',
    },
];
class BrnHoverCardContentService {
    _overlay = inject(Overlay);
    _zone = inject(NgZone);
    _psBuilder = inject(OverlayPositionBuilder);
    _content = signal(null);
    _state = signal('closed');
    _config = {};
    _overlayRef;
    _positionStrategy;
    _destroyed$ = new Subject();
    _positionChangesObservables$ = new BehaviorSubject(undefined);
    _overlayHoveredObservables$ = new BehaviorSubject(undefined);
    positionChanges$ = this._positionChangesObservables$.pipe(switchMap((positionChangeObservable) => (positionChangeObservable ? positionChangeObservable : of(undefined))), filter((change) => change !== undefined && change !== null));
    hovered$ = this._overlayHoveredObservables$.pipe(switchMap((overlayHoveredObservable) => (overlayHoveredObservable ? overlayHoveredObservable : of(false))));
    state = this._state.asReadonly();
    side = toSignal(this.positionChanges$.pipe(map((change) => 
    // todo: better translation or adjusting hlm to take that into account
    change.connectionPair.originY === 'center'
        ? change.connectionPair.originX === 'start'
            ? 'left'
            : 'right'
        : change.connectionPair.originY)), { initialValue: 'bottom' });
    setConfig(config) {
        this._config = config;
        if (config.attachTo) {
            this._positionStrategy = this._psBuilder
                .flexibleConnectedTo(config.attachTo)
                .withPositions((config.attachPositions ?? config.align === 'top') ? topFirstPositions : bottomFirstPositions)
                .withDefaultOffsetY(config.sideOffset ?? 0);
            this._config = {
                ...this._config,
                positionStrategy: this._positionStrategy,
                scrollStrategy: this._overlay.scrollStrategies.reposition(),
            };
            this._positionChangesObservables$.next(this._positionStrategy.positionChanges);
        }
        this._overlayRef = this._overlay.create(this._config);
    }
    setContent(value, vcr) {
        this._content.set(new TemplatePortal(value instanceof TemplateRef ? value : value.template, vcr));
        if (!this._overlayRef) {
            this._overlayRef = this._overlay.create(this._config);
        }
    }
    setState(newState) {
        this._state.set(newState);
    }
    show() {
        const content = this._content();
        if (!content || !this._overlayRef)
            return;
        this._overlayRef?.detach();
        this._overlayRef?.attach(content);
        this._destroyed$ = new Subject();
        this._overlayHoveredObservables$.next(createHoverObservable(this._overlayRef.hostElement, this._zone, this._destroyed$));
    }
    hide() {
        this._overlayRef?.detach();
        this._destroyed$.next();
        this._destroyed$.complete();
        this._destroyed$ = new Subject();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardContentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardContentService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardContentService, decorators: [{
            type: Injectable
        }] });
class BrnHoverCardTriggerDirective {
    _destroy$ = new Subject();
    _vcr = inject(ViewContainerRef);
    _zone = inject(NgZone);
    _el = inject(ElementRef);
    _contentService = inject(BrnHoverCardContentService);
    _focusMonitor = inject(FocusMonitor);
    focused$ = this._focusMonitor.monitor(this._el).pipe(map((e) => e !== null));
    hovered$ = merge(fromEvent(this._el.nativeElement, 'click').pipe(map(() => false)), createHoverObservable(this._el.nativeElement, this._zone, this._destroy$), this._contentService.hovered$, this.focused$).pipe(distinctUntilChanged());
    showing$ = this.hovered$.pipe(
    // we set the state to open here because we are about to open show the content
    tap((visible) => visible && this._contentService.setState('open')), switchMap((visible) => {
        // we are delaying based on the configure-able input
        return of(visible).pipe(delay(visible ? this.showDelay() : this.hideDelay()));
    }), switchMap((visible) => {
        // don't do anything when we are in the process of showing the content
        if (visible)
            return of(visible);
        // we set the state to closed here to trigger any animations for the element leaving
        this._contentService.setState('closed');
        // then delay to wait for the leaving animation to finish
        return of(visible).pipe(delay(this.animationDelay()));
    }), distinctUntilChanged(), share(), takeUntil(this._destroy$));
    showDelay = input(300);
    hideDelay = input(500);
    animationDelay = input(100);
    sideOffset = input(5);
    align = input('bottom');
    brnHoverCardTriggerFor = input(undefined);
    mutableBrnHoverCardTriggerFor = computed(() => signal(this.brnHoverCardTriggerFor()));
    _brnHoverCardTriggerForState = computed(() => this.mutableBrnHoverCardTriggerFor()());
    constructor() {
        effect(() => {
            const value = this._brnHoverCardTriggerForState();
            untracked(() => {
                if (value) {
                    this._contentService.setContent(value, this._vcr);
                }
            });
        });
    }
    ngOnInit() {
        this._contentService.setConfig({ attachTo: this._el, align: this.align(), sideOffset: this.sideOffset() });
        this.showing$.subscribe((isHovered) => {
            if (isHovered) {
                this._contentService.show();
            }
            else {
                this._contentService.hide();
            }
        });
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnHoverCardTriggerDirective, isStandalone: true, selector: "[brnHoverCardTrigger]:not(ng-container),[brnHoverCardTriggerFor]:not(ng-container)", inputs: { showDelay: { classPropertyName: "showDelay", publicName: "showDelay", isSignal: true, isRequired: false, transformFunction: null }, hideDelay: { classPropertyName: "hideDelay", publicName: "hideDelay", isSignal: true, isRequired: false, transformFunction: null }, animationDelay: { classPropertyName: "animationDelay", publicName: "animationDelay", isSignal: true, isRequired: false, transformFunction: null }, sideOffset: { classPropertyName: "sideOffset", publicName: "sideOffset", isSignal: true, isRequired: false, transformFunction: null }, align: { classPropertyName: "align", publicName: "align", isSignal: true, isRequired: false, transformFunction: null }, brnHoverCardTriggerFor: { classPropertyName: "brnHoverCardTriggerFor", publicName: "brnHoverCardTriggerFor", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["brnHoverCardTrigger"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnHoverCardTrigger]:not(ng-container),[brnHoverCardTriggerFor]:not(ng-container)',
                    standalone: true,
                    exportAs: 'brnHoverCardTrigger',
                }]
        }], ctorParameters: () => [] });

class BrnHoverCardComponent {
    _trigger = contentChild(BrnHoverCardTriggerDirective);
    _content = contentChild(BrnHoverCardContentDirective);
    ngAfterContentInit() {
        if (!this._trigger() || !this._content())
            return;
        this._trigger()?.mutableBrnHoverCardTriggerFor().set(this._content());
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.8", type: BrnHoverCardComponent, isStandalone: true, selector: "brn-hover-card", providers: [BrnHoverCardContentService], queries: [{ propertyName: "_trigger", first: true, predicate: BrnHoverCardTriggerDirective, descendants: true, isSignal: true }, { propertyName: "_content", first: true, predicate: BrnHoverCardContentDirective, descendants: true, isSignal: true }], ngImport: i0, template: `
		<ng-content />
	`, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-hover-card',
                    standalone: true,
                    providers: [BrnHoverCardContentService],
                    template: `
		<ng-content />
	`,
                }]
        }] });

const BrnHoverCardImports = [
    BrnHoverCardComponent,
    BrnHoverCardContentDirective,
    BrnHoverCardTriggerDirective,
];
class BrnHoverCardModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardModule, imports: [BrnHoverCardComponent,
            BrnHoverCardContentDirective,
            BrnHoverCardTriggerDirective], exports: [BrnHoverCardComponent,
            BrnHoverCardContentDirective,
            BrnHoverCardTriggerDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHoverCardModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnHoverCardImports],
                    exports: [...BrnHoverCardImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnHoverCardComponent, BrnHoverCardContentDirective, BrnHoverCardContentService, BrnHoverCardImports, BrnHoverCardModule, BrnHoverCardTriggerDirective, createHoverObservable, isElement };
//# sourceMappingURL=spartan-ng-brain-hover-card.mjs.map
