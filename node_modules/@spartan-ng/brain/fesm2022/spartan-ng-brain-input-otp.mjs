import * as i0 from '@angular/core';
import { InjectionToken, inject, input, numberAttribute, computed, Component, forwardRef, signal, booleanAttribute, model, output, NgModule } from '@angular/core';
import * as i1 from '@angular/forms';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';

const BrnInputOtpToken = new InjectionToken('BrnInputOtpToken');
function injectBrnInputOtp() {
    return inject(BrnInputOtpToken);
}
function provideBrnInputOtp(inputOtp) {
    return { provide: BrnInputOtpToken, useExisting: inputOtp };
}

class BrnInputOtpSlotComponent {
    /** Access the input-otp component */
    inputOtp = injectBrnInputOtp();
    index = input.required({ transform: numberAttribute });
    slot = computed(() => this.inputOtp.context()[this.index()]);
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnInputOtpSlotComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.8", type: BrnInputOtpSlotComponent, isStandalone: true, selector: "brn-input-otp-slot", inputs: { index: { classPropertyName: "index", publicName: "index", isSignal: true, isRequired: true, transformFunction: null } }, host: { properties: { "attr.data-active": "slot().isActive" } }, ngImport: i0, template: `
		{{ slot().char }}

		@if (slot().hasFakeCaret) {
			<ng-content />
		}
	`, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnInputOtpSlotComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-input-otp-slot',
                    standalone: true,
                    template: `
		{{ slot().char }}

		@if (slot().hasFakeCaret) {
			<ng-content />
		}
	`,
                    host: {
                        '[attr.data-active]': 'slot().isActive',
                    },
                }]
        }] });

const BRN_INPUT_OTP_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => BrnInputOtpComponent),
    multi: true,
};
class BrnInputOtpComponent {
    /** Whether the input has focus. */
    focused = signal(false);
    hostStyles = input('position: relative; cursor: text; user-select: none; pointer-events: none;');
    inputStyles = input('position: absolute; inset: 0; width: 100%; height: 100%; display: flex; textAlign: left; opacity: 1; color: transparent; pointerEvents: all; background: transparent; caret-color: transparent; border: 0px solid transparent; outline: transparent solid 0px; box-shadow: none; line-height: 1; letter-spacing: -0.5em; font-family: monospace; font-variant-numeric: tabular-nums;');
    containerStyles = input('position: absolute; inset: 0; pointer-events: none;');
    /** Determine if the date picker is disabled. */
    disabled = input(false, {
        transform: booleanAttribute,
    });
    /** The number of slots. */
    maxLength = input.required({ transform: numberAttribute });
    /** Virtual keyboard appearance on mobile */
    inputMode = input('numeric');
    inputClass = input('');
    /**
     * Defines how the pasted text should be transformed before saving to model/form.
     * Allows pasting text which contains extra characters like spaces, dashes, etc. and are longer than the maxLength.
     *
     * "XXX-XXX": (pastedText) => pastedText.replaceAll('-', '')
     * "XXX XXX": (pastedText) => pastedText.replaceAll(/\s+/g, '')
     */
    transformPaste = input((text) => text);
    /** The value controlling the input */
    value = model('');
    context = computed(() => {
        const value = this.value();
        const focused = this.focused();
        const maxLength = this.maxLength();
        const slots = Array.from({ length: this.maxLength() }).map((_, slotIndex) => {
            const char = value[slotIndex] !== undefined ? value[slotIndex] : null;
            const isActive = focused && (value.length === slotIndex || (value.length === maxLength && slotIndex === maxLength - 1));
            return {
                char,
                isActive,
                hasFakeCaret: isActive && value.length === slotIndex,
            };
        });
        return slots;
    });
    /** Emitted when the input is complete, triggered through input or paste.  */
    completed = output();
    state = computed(() => ({
        disabled: signal(this.disabled()),
    }));
    _onChange;
    _onTouched;
    onInputChange(event) {
        let newValue = event.target.value;
        const maxLength = this.maxLength();
        if (newValue.length > maxLength) {
            // Replace the last character when max length is exceeded
            newValue = newValue.slice(0, maxLength - 1) + newValue.slice(-1);
        }
        this.updateValue(newValue, maxLength);
    }
    onPaste(event) {
        event.preventDefault();
        const clipboardData = event.clipboardData?.getData('text/plain') || '';
        const maxLength = this.maxLength();
        const content = this.transformPaste()(clipboardData, maxLength);
        const newValue = content.slice(0, maxLength);
        this.updateValue(newValue, maxLength);
    }
    /** CONTROL VALUE ACCESSOR */
    writeValue(value) {
        // optional FormControl is initialized with null value
        if (value === null)
            return;
        this.updateValue(value, this.maxLength());
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.state().disabled.set(isDisabled);
    }
    isCompleted(newValue, previousValue, maxLength) {
        return newValue !== previousValue && previousValue.length < maxLength && newValue.length === maxLength;
    }
    updateValue(newValue, maxLength) {
        const previousValue = this.value();
        this.value.set(newValue);
        this._onChange?.(newValue);
        if (this.isCompleted(newValue, previousValue, maxLength)) {
            this.completed.emit(newValue);
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnInputOtpComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.8", type: BrnInputOtpComponent, isStandalone: true, selector: "brn-input-otp", inputs: { hostStyles: { classPropertyName: "hostStyles", publicName: "hostStyles", isSignal: true, isRequired: false, transformFunction: null }, inputStyles: { classPropertyName: "inputStyles", publicName: "inputStyles", isSignal: true, isRequired: false, transformFunction: null }, containerStyles: { classPropertyName: "containerStyles", publicName: "containerStyles", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, maxLength: { classPropertyName: "maxLength", publicName: "maxLength", isSignal: true, isRequired: true, transformFunction: null }, inputMode: { classPropertyName: "inputMode", publicName: "inputMode", isSignal: true, isRequired: false, transformFunction: null }, inputClass: { classPropertyName: "inputClass", publicName: "inputClass", isSignal: true, isRequired: false, transformFunction: null }, transformPaste: { classPropertyName: "transformPaste", publicName: "transformPaste", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { value: "valueChange", completed: "completed" }, host: { attributes: { "data-input-otp-container": "true" }, properties: { "style": "hostStyles()" } }, providers: [BRN_INPUT_OTP_VALUE_ACCESSOR, provideBrnInputOtp(BrnInputOtpComponent)], ngImport: i0, template: `
		<ng-content />
		<div [style]="containerStyles()">
			<input
				[class]="inputClass()"
				autocomplete="one-time-code"
				data-slot="input-otp"
				[style]="inputStyles()"
				[disabled]="state().disabled()"
				[inputMode]="inputMode()"
				[ngModel]="value()"
				(input)="onInputChange($event)"
				(paste)="onPaste($event)"
				(focus)="focused.set(true)"
				(blur)="focused.set(false)"
			/>
		</div>
	`, isInline: true, dependencies: [{ kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnInputOtpComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-input-otp',
                    imports: [FormsModule],
                    template: `
		<ng-content />
		<div [style]="containerStyles()">
			<input
				[class]="inputClass()"
				autocomplete="one-time-code"
				data-slot="input-otp"
				[style]="inputStyles()"
				[disabled]="state().disabled()"
				[inputMode]="inputMode()"
				[ngModel]="value()"
				(input)="onInputChange($event)"
				(paste)="onPaste($event)"
				(focus)="focused.set(true)"
				(blur)="focused.set(false)"
			/>
		</div>
	`,
                    host: {
                        '[style]': 'hostStyles()',
                        'data-input-otp-container': 'true',
                    },
                    providers: [BRN_INPUT_OTP_VALUE_ACCESSOR, provideBrnInputOtp(BrnInputOtpComponent)],
                }]
        }] });

class BrnInputOtpModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnInputOtpModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnInputOtpModule, imports: [BrnInputOtpComponent, BrnInputOtpSlotComponent], exports: [BrnInputOtpComponent, BrnInputOtpSlotComponent] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnInputOtpModule, imports: [BrnInputOtpComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnInputOtpModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [BrnInputOtpComponent, BrnInputOtpSlotComponent],
                    exports: [BrnInputOtpComponent, BrnInputOtpSlotComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BRN_INPUT_OTP_VALUE_ACCESSOR, BrnInputOtpComponent, BrnInputOtpModule, BrnInputOtpSlotComponent };
//# sourceMappingURL=spartan-ng-brain-input-otp.mjs.map
