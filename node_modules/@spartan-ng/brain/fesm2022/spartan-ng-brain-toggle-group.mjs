import * as i0 from '@angular/core';
import { InjectionToken, inject, forwardRef, input, booleanAttribute, model, computed, signal, output, Component, ChangeDetectorRef, Directive, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';

const BrnToggleGroupToken = new InjectionToken('BrnToggleGroupToken');
function injectBrnToggleGroup() {
    return inject(BrnToggleGroupToken, { optional: true });
}
function provideBrnToggleGroup(value) {
    return { provide: BrnToggleGroupToken, useExisting: value };
}

const BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => BrnToggleGroupComponent),
    multi: true,
};
class BrnButtonToggleChange {
    source;
    value;
    constructor(source, value) {
        this.source = source;
        this.value = value;
    }
}
class BrnToggleGroupComponent {
    /**
     * The method to be called in order to update ngModel.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    _onChange = () => { };
    /** onTouch function registered via registerOnTouch (ControlValueAccessor). */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onTouched = () => { };
    /** Whether the button toggle group has a vertical orientation */
    vertical = input(false, {
        transform: booleanAttribute,
    });
    /** Value of the toggle group. */
    value = model(undefined);
    /** Whether no button toggles need to be selected. */
    nullable = input(false, {
        transform: booleanAttribute,
    });
    /** Whether multiple button toggles can be selected. */
    multiple = input(false, {
        transform: booleanAttribute,
    });
    /** Whether the button toggle group is disabled. */
    disabled = input(false, {
        transform: booleanAttribute,
    });
    /** The internal state of the component. This can be replaced with linkedSignal in the future. */
    state = computed(() => ({
        disabled: signal(this.disabled()),
    }));
    /** Emit event when the group value changes. */
    change = output();
    writeValue(value) {
        this.value.set(value);
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.state().disabled.set(isDisabled);
    }
    /**
     * @internal
     * Determines whether a value can be set on the group.
     */
    canDeselect(value) {
        // if null values are allowed, the group can always be nullable
        if (this.nullable())
            return true;
        const currentValue = this.value();
        if (this.multiple() && Array.isArray(currentValue)) {
            return !(currentValue.length === 1 && currentValue[0] === value);
        }
        return currentValue !== value;
    }
    /**
     * @internal
     * Selects a value.
     */
    select(value, source) {
        if (this.state().disabled() || this.isSelected(value)) {
            return;
        }
        const currentValue = this.value();
        // emit the valueChange event here as we should only emit based on user interaction
        if (this.multiple()) {
            this.emitSelectionChange([...(currentValue ?? []), value], source);
        }
        else {
            this.emitSelectionChange(value, source);
        }
        this._onChange(this.value());
        this.change.emit(new BrnButtonToggleChange(source, this.value()));
    }
    /**
     * @internal
     * Deselects a value.
     */
    deselect(value, source) {
        if (this.state().disabled() || !this.isSelected(value) || !this.canDeselect(value)) {
            return;
        }
        const currentValue = this.value();
        if (this.multiple()) {
            this.emitSelectionChange((currentValue ?? []).filter((v) => v !== value), source);
        }
        else if (currentValue === value) {
            this.emitSelectionChange(null, source);
        }
    }
    /**
     * @internal
     * Determines whether a value is selected.
     */
    isSelected(value) {
        const currentValue = this.value();
        if (currentValue == null ||
            currentValue === undefined ||
            (Array.isArray(currentValue) && currentValue.length === 0)) {
            return false;
        }
        if (this.multiple()) {
            return currentValue?.includes(value);
        }
        return currentValue === value;
    }
    /** Update the value of the group */
    emitSelectionChange(value, source) {
        this.value.set(value);
        this._onChange(value);
        this.change.emit(new BrnButtonToggleChange(source, this.value()));
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.8", type: BrnToggleGroupComponent, isStandalone: true, selector: "brn-toggle-group", inputs: { vertical: { classPropertyName: "vertical", publicName: "vertical", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, nullable: { classPropertyName: "nullable", publicName: "nullable", isSignal: true, isRequired: false, transformFunction: null }, multiple: { classPropertyName: "multiple", publicName: "multiple", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { value: "valueChange", change: "change" }, host: { attributes: { "role": "group" }, listeners: { "focusout": "onTouched()" }, properties: { "attr.aria-disabled": "state().disabled()", "attr.data-disabled": "state().disabled()", "attr.data-vertical": "vertical()" }, classAttribute: "brn-button-toggle-group" }, providers: [provideBrnToggleGroup(BrnToggleGroupComponent), BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR], exportAs: ["brnToggleGroup"], ngImport: i0, template: `
		<ng-content />
	`, isInline: true });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-toggle-group',
                    standalone: true,
                    providers: [provideBrnToggleGroup(BrnToggleGroupComponent), BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR],
                    host: {
                        role: 'group',
                        class: 'brn-button-toggle-group',
                        '[attr.aria-disabled]': 'state().disabled()',
                        '[attr.data-disabled]': 'state().disabled()',
                        '[attr.data-vertical]': 'vertical()',
                        '(focusout)': 'onTouched()',
                    },
                    exportAs: 'brnToggleGroup',
                    template: `
		<ng-content />
	`,
                }]
        }] });

class BrnToggleGroupItemDirective {
    static _uniqueId = 0;
    _changeDetector = inject(ChangeDetectorRef);
    /** Access the toggle group if available. */
    group = injectBrnToggleGroup();
    /** The id of the toggle. */
    id = input(`brn-toggle-group-item-${BrnToggleGroupItemDirective._uniqueId++}`);
    /** The value this toggle represents. */
    value = input();
    /** Whether the toggle is disabled. */
    disabled = input(false, {
        transform: booleanAttribute,
    });
    /** The current state of the toggle when not used in a group. */
    state = model('off');
    /** Whether the toggle is responds to click events. */
    disableToggleClick = input(false, {
        transform: booleanAttribute,
    });
    /** Whether the toggle is in the on state. */
    isOn = computed(() => this._state() === 'on');
    /** The current state that reflects the group state or the model state. */
    _state = computed(() => {
        if (this.group) {
            return this.group.isSelected(this.value()) ? 'on' : 'off';
        }
        return this.state();
    });
    toggle() {
        if (this.disableToggleClick())
            return;
        if (this.group) {
            if (this.isOn()) {
                this.group.deselect(this.value(), this);
            }
            else {
                this.group.select(this.value(), this);
            }
        }
        else {
            this.state.set(this.isOn() ? 'off' : 'on');
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnToggleGroupItemDirective, isStandalone: true, selector: "button[hlmToggleGroupItem], button[brnToggleGroupItem]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, state: { classPropertyName: "state", publicName: "state", isSignal: true, isRequired: false, transformFunction: null }, disableToggleClick: { classPropertyName: "disableToggleClick", publicName: "disableToggleClick", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { state: "stateChange" }, host: { listeners: { "click": "toggle()" }, properties: { "id": "id()", "attr.disabled": "disabled() || group?.disabled() ? true : null", "attr.data-disabled": "disabled() || group?.disabled() ? true : null", "attr.data-state": "_state()", "attr.aria-pressed": "isOn()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'button[hlmToggleGroupItem], button[brnToggleGroupItem]',
                    standalone: true,
                    host: {
                        '[id]': 'id()',
                        '[attr.disabled]': 'disabled() || group?.disabled() ? true : null',
                        '[attr.data-disabled]': 'disabled() || group?.disabled() ? true : null',
                        '[attr.data-state]': '_state()',
                        '[attr.aria-pressed]': 'isOn()',
                        '(click)': 'toggle()',
                    },
                }]
        }] });

class BrnToggleGroupModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupModule, imports: [BrnToggleGroupItemDirective, BrnToggleGroupComponent], exports: [BrnToggleGroupItemDirective, BrnToggleGroupComponent] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [BrnToggleGroupItemDirective, BrnToggleGroupComponent],
                    exports: [BrnToggleGroupItemDirective, BrnToggleGroupComponent],
                }]
        }] });
class BrnToggleGroupItemModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupItemModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupItemModule, imports: [BrnToggleGroupItemDirective], exports: [BrnToggleGroupItemDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupItemModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnToggleGroupItemModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [BrnToggleGroupItemDirective],
                    exports: [BrnToggleGroupItemDirective],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BRN_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, BrnButtonToggleChange, BrnToggleGroupComponent, BrnToggleGroupItemDirective, BrnToggleGroupItemModule, BrnToggleGroupModule };
//# sourceMappingURL=spartan-ng-brain-toggle-group.mjs.map
