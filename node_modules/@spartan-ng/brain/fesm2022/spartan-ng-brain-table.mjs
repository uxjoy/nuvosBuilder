import * as i0 from '@angular/core';
import { inject, TemplateRef, Directive, input, ContentChild, ViewChild, Input, ViewEncapsulation, ChangeDetectionStrategy, Component, ViewContainerRef, signal, computed, effect, untracked, numberAttribute, EventEmitter, booleanAttribute, ContentChildren, Output, NgModule } from '@angular/core';
import * as i1 from '@angular/cdk/table';
import { CdkCellDef, CdkFooterCellDef, CdkHeaderCellDef, CdkTableModule, CdkColumnDef, CdkTable, CdkRowDef } from '@angular/cdk/table';
import { provideTableClassesSettableExisting } from '@spartan-ng/brain/core';

class BrnCellDefDirective extends CdkCellDef {
    template;
    constructor() {
        const template = inject(TemplateRef);
        super(template);
        this.template = template;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCellDefDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnCellDefDirective, isStandalone: true, selector: "[brnCellDef]", exportAs: ["brnCellDef"], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCellDefDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[brnCellDef]',
                    exportAs: 'brnCellDef',
                }]
        }], ctorParameters: () => [] });

class BrnFooterDefDirective extends CdkFooterCellDef {
    template;
    constructor() {
        const template = inject(TemplateRef);
        super(template);
        this.template = template;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnFooterDefDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnFooterDefDirective, isStandalone: true, selector: "[brnFooterDef]", exportAs: ["brnFooterDef"], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnFooterDefDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[brnFooterDef]',
                    exportAs: 'brnFooterDef',
                }]
        }], ctorParameters: () => [] });

class BrnHeaderDefDirective extends CdkHeaderCellDef {
    template;
    constructor() {
        const template = inject(TemplateRef);
        super(template);
        this.template = template;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHeaderDefDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnHeaderDefDirective, isStandalone: true, selector: "[brnHeaderDef]", exportAs: ["brnHeaderDef"], usesInheritance: true, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnHeaderDefDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[brnHeaderDef]',
                    exportAs: 'brnHeaderDef',
                }]
        }], ctorParameters: () => [] });

class BrnColumnDefComponent {
    get columnDef() {
        return this._columnDef;
    }
    get cell() {
        return this._columnDef.cell;
    }
    _name = '';
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
        if (!this._columnDef)
            return;
        this._columnDef.name = value;
    }
    class = input('');
    _columnDef;
    _cellDef;
    _footerCellDef;
    _headerCellDef;
    ngAfterContentChecked() {
        this._columnDef.name = this.name;
        if (this._cellDef) {
            this._columnDef.cell = this._cellDef;
        }
        if (this._headerCellDef) {
            this._columnDef.headerCell = this._headerCellDef;
        }
        if (this._footerCellDef) {
            this._columnDef.footerCell = this._footerCellDef;
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnColumnDefComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.8", type: BrnColumnDefComponent, isStandalone: true, selector: "brn-column-def", inputs: { name: { classPropertyName: "name", publicName: "name", isSignal: false, isRequired: false, transformFunction: null }, class: { classPropertyName: "class", publicName: "class", isSignal: true, isRequired: false, transformFunction: null } }, queries: [{ propertyName: "_cellDef", first: true, predicate: BrnCellDefDirective, descendants: true, static: true }, { propertyName: "_footerCellDef", first: true, predicate: BrnFooterDefDirective, descendants: true, static: true }, { propertyName: "_headerCellDef", first: true, predicate: BrnHeaderDefDirective, descendants: true, static: true }], viewQueries: [{ propertyName: "_columnDef", first: true, predicate: CdkColumnDef, descendants: true, static: true }], ngImport: i0, template: `
		<ng-container [cdkColumnDef]="name">
			<ng-content select="[brnHeaderDef]" />
			<ng-content select="[brnCellDef]" />
			<ng-content select="[brnFooterDef]" />
		</ng-container>
	`, isInline: true, dependencies: [{ kind: "ngmodule", type: CdkTableModule }, { kind: "directive", type: i1.CdkColumnDef, selector: "[cdkColumnDef]", inputs: ["cdkColumnDef", "sticky", "stickyEnd"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnColumnDefComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-column-def',
                    imports: [CdkTableModule],
                    template: `
		<ng-container [cdkColumnDef]="name">
			<ng-content select="[brnHeaderDef]" />
			<ng-content select="[brnCellDef]" />
			<ng-content select="[brnFooterDef]" />
		</ng-container>
	`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }], propDecorators: { name: [{
                type: Input
            }], _columnDef: [{
                type: ViewChild,
                args: [CdkColumnDef, { static: true }]
            }], _cellDef: [{
                type: ContentChild,
                args: [BrnCellDefDirective, { static: true }]
            }], _footerCellDef: [{
                type: ContentChild,
                args: [BrnFooterDefDirective, { static: true }]
            }], _headerCellDef: [{
                type: ContentChild,
                args: [BrnHeaderDefDirective, { static: true }]
            }] } });

class BrnPaginatorDirective {
    static ngTemplateContextGuard(_directive, _context) {
        return true;
    }
    _vcr = inject(ViewContainerRef);
    _template = inject((TemplateRef));
    _state = signal({
        currentPage: 0,
        startIndex: 0,
        endIndex: 0,
        pageSize: 10,
        totalPages: 0,
        totalElements: null,
    });
    _decrementable = computed(() => 0 < this._state().startIndex);
    _incrementable = computed(() => this._state().endIndex < (this._state().totalElements ?? 0) - 1);
    set totalElements(value) {
        this.calculateNewState({ newTotalElements: value, newPage: 0 });
    }
    set currentPage(value) {
        this.calculateNewState({ newPage: value });
    }
    set pageSize(value) {
        this.calculateNewState({ newPageSize: value, newPage: 0 });
    }
    onStateChange;
    constructor() {
        effect(() => {
            const state = this._state();
            untracked(() => {
                Promise.resolve().then(() => {
                    if (this.onStateChange) {
                        this.onStateChange(state);
                    }
                });
            });
        });
    }
    ngOnInit() {
        this._vcr.createEmbeddedView(this._template, {
            $implicit: {
                state: this._state,
                increment: () => this.incrementPage(),
                decrement: () => this.decrementPage(),
                incrementable: this._incrementable,
                decrementable: this._decrementable,
            },
        });
    }
    decrementPage() {
        const { currentPage } = this._state();
        if (0 < currentPage) {
            this.calculateNewState({ newPage: currentPage - 1 });
        }
    }
    incrementPage() {
        const { currentPage, totalPages } = this._state();
        if (totalPages > currentPage) {
            this.calculateNewState({ newPage: currentPage + 1 });
        }
    }
    reset() {
        this.currentPage = 0;
    }
    calculateNewState({ newPage, newPageSize, newTotalElements, }) {
        const previousState = this._state();
        let currentPage = newPage ?? previousState.currentPage;
        const pageSize = newPageSize ?? previousState.pageSize;
        const totalElements = newTotalElements ?? previousState.totalElements ?? 0;
        const newTotalPages = totalElements ? Math.floor(totalElements / pageSize) : 0;
        if (newTotalPages < currentPage - 1) {
            currentPage = newTotalPages - 1;
        }
        const newStartIndex = totalElements === 0 ? 0 : Math.min(totalElements - 1, currentPage * pageSize);
        const newEndIndex = Math.min((currentPage + 1) * pageSize - 1, totalElements - 1);
        const newState = {
            currentPage: currentPage,
            startIndex: newStartIndex,
            endIndex: newEndIndex,
            pageSize: pageSize,
            totalPages: newTotalPages,
            totalElements: totalElements,
        };
        this._state.set(newState);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnPaginatorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "19.2.8", type: BrnPaginatorDirective, isStandalone: true, selector: "[brnPaginator]", inputs: { totalElements: ["brnPaginatorTotalElements", "totalElements"], currentPage: ["brnPaginatorCurrentPage", "currentPage", numberAttribute], pageSize: ["brnPaginatorPageSize", "pageSize", numberAttribute], onStateChange: ["brnPaginatorOnStateChange", "onStateChange"] }, exportAs: ["brnPaginator"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnPaginatorDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[brnPaginator]',
                    exportAs: 'brnPaginator',
                }]
        }], ctorParameters: () => [], propDecorators: { totalElements: [{
                type: Input,
                args: [{ alias: 'brnPaginatorTotalElements' }]
            }], currentPage: [{
                type: Input,
                args: [{ alias: 'brnPaginatorCurrentPage', transform: numberAttribute }]
            }], pageSize: [{
                type: Input,
                args: [{ alias: 'brnPaginatorPageSize', transform: numberAttribute }]
            }], onStateChange: [{
                type: Input,
                args: [{ alias: 'brnPaginatorOnStateChange' }]
            }] } });

class BrnTableComponent {
    _cdkTable;
    // Cdk Table Inputs / Outputs
    dataSource = [];
    fixedLayout = false;
    multiTemplateDataRows = false;
    displayedColumns = [];
    _trackBy;
    get trackBy() {
        return this._trackBy;
    }
    set trackBy(value) {
        this._trackBy = value;
        if (this._cdkTable) {
            this._cdkTable.trackBy = this._trackBy;
        }
    }
    contentChanged = new EventEmitter();
    // Brn Inputs / Outputs
    customTemplateDataRows = false;
    onRowClick;
    stickyHeader = false;
    tableClasses = '';
    headerRowClasses = '';
    bodyRowClasses = '';
    columnDefComponents;
    rowDefs;
    // after the <ng-content> has been initialized, the column definitions are available.
    // All that's left is to add them to the table ourselves:
    ngAfterContentInit() {
        this.columnDefComponents.forEach((component) => {
            if (!this._cdkTable)
                return;
            if (component.cell) {
                this._cdkTable.addColumnDef(component.columnDef);
            }
        });
        this.rowDefs.forEach((rowDef) => {
            if (!this._cdkTable)
                return;
            this._cdkTable.addRowDef(rowDef);
        });
    }
    setTableClasses({ table, headerRow, bodyRow, }) {
        if (table) {
            this.tableClasses = table;
        }
        if (headerRow) {
            this.headerRowClasses = headerRow;
        }
        if (bodyRow) {
            this.bodyRowClasses = bodyRow;
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnTableComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.8", type: BrnTableComponent, isStandalone: true, selector: "brn-table", inputs: { dataSource: "dataSource", fixedLayout: ["fixedLayout", "fixedLayout", booleanAttribute], multiTemplateDataRows: ["multiTemplateDataRows", "multiTemplateDataRows", booleanAttribute], displayedColumns: "displayedColumns", trackBy: "trackBy", customTemplateDataRows: ["customTemplateDataRows", "customTemplateDataRows", booleanAttribute], onRowClick: "onRowClick", stickyHeader: ["stickyHeader", "stickyHeader", booleanAttribute], tableClasses: "tableClasses", headerRowClasses: "headerRowClasses", bodyRowClasses: "bodyRowClasses" }, outputs: { contentChanged: "contentChanged" }, providers: [provideTableClassesSettableExisting((() => BrnTableComponent))], queries: [{ propertyName: "columnDefComponents", predicate: BrnColumnDefComponent }, { propertyName: "rowDefs", predicate: CdkRowDef }], viewQueries: [{ propertyName: "_cdkTable", first: true, predicate: ["cdkTable"], descendants: true, read: CdkTable, static: true }], ngImport: i0, template: `
		<cdk-table
			#cdkTable
			[class]="tableClasses"
			[dataSource]="dataSource"
			[fixedLayout]="fixedLayout"
			[multiTemplateDataRows]="multiTemplateDataRows"
			(contentChanged)="contentChanged.emit()"
		>
			<ng-content />

			<cdk-header-row [class]="headerRowClasses" *cdkHeaderRowDef="displayedColumns; sticky: stickyHeader" />
			@if (!customTemplateDataRows) {
				<cdk-row
					[tabindex]="!!onRowClick ? 0 : -1"
					[attr.role]="!!onRowClick ? 'button' : 'row'"
					[class.row-interactive]="!!onRowClick"
					(keydown.enter)="!!onRowClick && onRowClick(row)"
					(click)="!!onRowClick && onRowClick(row)"
					[class]="bodyRowClasses"
					*cdkRowDef="let row; columns: displayedColumns"
				/>
			}

			<ng-template cdkNoDataRow>
				<ng-content select="[brnNoDataRow]" />
			</ng-template>
		</cdk-table>
	`, isInline: true, dependencies: [{ kind: "ngmodule", type: CdkTableModule }, { kind: "component", type: i1.CdkTable, selector: "cdk-table, table[cdk-table]", inputs: ["trackBy", "dataSource", "multiTemplateDataRows", "fixedLayout"], outputs: ["contentChanged"], exportAs: ["cdkTable"] }, { kind: "directive", type: i1.CdkRowDef, selector: "[cdkRowDef]", inputs: ["cdkRowDefColumns", "cdkRowDefWhen"] }, { kind: "component", type: i1.CdkRow, selector: "cdk-row, tr[cdk-row]" }, { kind: "component", type: i1.CdkHeaderRow, selector: "cdk-header-row, tr[cdk-header-row]" }, { kind: "directive", type: i1.CdkHeaderRowDef, selector: "[cdkHeaderRowDef]", inputs: ["cdkHeaderRowDef", "cdkHeaderRowDefSticky"] }, { kind: "directive", type: i1.CdkNoDataRow, selector: "ng-template[cdkNoDataRow]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnTableComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-table',
                    imports: [CdkTableModule],
                    providers: [provideTableClassesSettableExisting((() => BrnTableComponent))],
                    template: `
		<cdk-table
			#cdkTable
			[class]="tableClasses"
			[dataSource]="dataSource"
			[fixedLayout]="fixedLayout"
			[multiTemplateDataRows]="multiTemplateDataRows"
			(contentChanged)="contentChanged.emit()"
		>
			<ng-content />

			<cdk-header-row [class]="headerRowClasses" *cdkHeaderRowDef="displayedColumns; sticky: stickyHeader" />
			@if (!customTemplateDataRows) {
				<cdk-row
					[tabindex]="!!onRowClick ? 0 : -1"
					[attr.role]="!!onRowClick ? 'button' : 'row'"
					[class.row-interactive]="!!onRowClick"
					(keydown.enter)="!!onRowClick && onRowClick(row)"
					(click)="!!onRowClick && onRowClick(row)"
					[class]="bodyRowClasses"
					*cdkRowDef="let row; columns: displayedColumns"
				/>
			}

			<ng-template cdkNoDataRow>
				<ng-content select="[brnNoDataRow]" />
			</ng-template>
		</cdk-table>
	`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }], propDecorators: { _cdkTable: [{
                type: ViewChild,
                args: ['cdkTable', { read: CdkTable, static: true }]
            }], dataSource: [{
                type: Input
            }], fixedLayout: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], multiTemplateDataRows: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], displayedColumns: [{
                type: Input
            }], trackBy: [{
                type: Input
            }], contentChanged: [{
                type: Output
            }], customTemplateDataRows: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], onRowClick: [{
                type: Input
            }], stickyHeader: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], tableClasses: [{
                type: Input
            }], headerRowClasses: [{
                type: Input
            }], bodyRowClasses: [{
                type: Input
            }], columnDefComponents: [{
                type: ContentChildren,
                args: [BrnColumnDefComponent]
            }], rowDefs: [{
                type: ContentChildren,
                args: [CdkRowDef]
            }] } });

class BrnColumnManager {
    _initialColumnVisibility;
    _columnVisibility;
    allColumns;
    columnVisibility;
    displayedColumns = computed(() => {
        return Object.entries(this._columnVisibility())
            .filter(([, value]) => (typeof value === 'boolean' ? value : value.visible))
            .map(([key]) => key);
    });
    constructor(initialColumnVisibility) {
        this._initialColumnVisibility = initialColumnVisibility;
        this._columnVisibility = signal(this._initialColumnVisibility);
        this._columnVisibility.set(this._initialColumnVisibility);
        this.columnVisibility = this._columnVisibility.asReadonly();
        this.allColumns = this.createAllColumns(this._initialColumnVisibility);
    }
    isColumnVisible = (columnName) => {
        const visibilityMap = this.columnVisibility();
        const columnEntry = visibilityMap[columnName];
        return typeof columnEntry === 'boolean' ? columnEntry : columnEntry.visible;
    };
    isColumnDisabled = (columnName) => this.isColumnVisible(columnName) && this.displayedColumns().length === 1;
    toggleVisibility(columnName) {
        const visibilityMap = this._columnVisibility();
        const columnEntry = visibilityMap[columnName];
        const newVisibilityState = typeof columnEntry === 'boolean' ? !columnEntry : { visible: !columnEntry.visible };
        this._columnVisibility.set({ ...visibilityMap, [columnName]: newVisibilityState });
    }
    setVisible(columnName) {
        const visibilityMap = this._columnVisibility();
        const columnEntry = visibilityMap[columnName];
        const newVisibilityState = typeof columnEntry === 'boolean' ? true : { visible: true };
        this._columnVisibility.set({ ...visibilityMap, [columnName]: newVisibilityState });
    }
    setInvisible(columnName) {
        const visibilityMap = this._columnVisibility();
        const columnEntry = visibilityMap[columnName];
        const newVisibilityState = typeof columnEntry === 'boolean' ? false : { visible: false };
        this._columnVisibility.set({ ...visibilityMap, [columnName]: newVisibilityState });
    }
    createAllColumns(initialColumnVisibility) {
        const keys = Object.keys(initialColumnVisibility);
        if (this.isBooleanConfig(initialColumnVisibility)) {
            return keys;
        }
        return keys.map((key) => {
            const values = initialColumnVisibility[key];
            return {
                name: key,
                ...values,
            };
        });
    }
    isBooleanConfig(config) {
        return typeof Object.values(config)[0] === 'boolean';
    }
}
const useBrnColumnManager = (initialColumnVisibility) => new BrnColumnManager(initialColumnVisibility);

const BrnTableImports = [
    BrnCellDefDirective,
    BrnColumnDefComponent,
    BrnFooterDefDirective,
    BrnHeaderDefDirective,
    BrnTableComponent,
    BrnPaginatorDirective,
];
class BrnTableModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnTableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnTableModule, imports: [BrnCellDefDirective,
            BrnColumnDefComponent,
            BrnFooterDefDirective,
            BrnHeaderDefDirective,
            BrnTableComponent,
            BrnPaginatorDirective], exports: [BrnCellDefDirective,
            BrnColumnDefComponent,
            BrnFooterDefDirective,
            BrnHeaderDefDirective,
            BrnTableComponent,
            BrnPaginatorDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnTableModule, imports: [BrnColumnDefComponent,
            BrnTableComponent] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnTableModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnTableImports],
                    exports: [...BrnTableImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnCellDefDirective, BrnColumnDefComponent, BrnColumnManager, BrnFooterDefDirective, BrnHeaderDefDirective, BrnPaginatorDirective, BrnTableComponent, BrnTableImports, BrnTableModule, useBrnColumnManager };
//# sourceMappingURL=spartan-ng-brain-table.mjs.map
