import * as i0 from '@angular/core';
import { inject, input, computed, effect, untracked, Directive, ElementRef, HostListener, signal, contentChildren, ViewEncapsulation, ChangeDetectionStrategy, Component, NgModule } from '@angular/core';
import { FocusMonitor, FocusKeyManager } from '@angular/cdk/a11y';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent } from 'rxjs';

class BrnAccordionItemDirective {
    static _itemIdGenerator = 0;
    _accordion = inject(BrnAccordionDirective);
    isOpened = input(false, { transform: coerceBooleanProperty });
    id = BrnAccordionItemDirective._itemIdGenerator++;
    state = computed(() => (this._accordion.openItemIds().includes(this.id) ? 'open' : 'closed'));
    constructor() {
        if (!this._accordion) {
            throw Error('Accordion trigger can only be used inside an Accordion. Add brnAccordion to ancestor.');
        }
        effect(() => {
            const isOpened = this.isOpened();
            untracked(() => {
                if (isOpened) {
                    this._accordion.openItem(this.id);
                }
                else {
                    this._accordion.closeItem(this.id);
                }
            });
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnAccordionItemDirective, isStandalone: true, selector: "[brnAccordionItem]", inputs: { isOpened: { classPropertyName: "isOpened", publicName: "isOpened", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.data-state": "state()" } }, exportAs: ["brnAccordionItem"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnAccordionItem]',
                    standalone: true,
                    host: {
                        '[attr.data-state]': 'state()',
                    },
                    exportAs: 'brnAccordionItem',
                }]
        }], ctorParameters: () => [] });
class BrnAccordionTriggerDirective {
    _accordion = inject(BrnAccordionDirective);
    _item = inject(BrnAccordionItemDirective);
    _elementRef = inject(ElementRef);
    state = this._item.state;
    id = `brn-accordion-trigger-${this._item.id}`;
    ariaControls = `brn-accordion-content-${this._item.id}`;
    constructor() {
        if (!this._accordion) {
            throw Error('Accordion trigger can only be used inside an Accordion. Add brnAccordion to ancestor.');
        }
        if (!this._item) {
            throw Error('Accordion trigger can only be used inside an AccordionItem. Add brnAccordionItem to parent.');
        }
        fromEvent(this._elementRef.nativeElement, 'focus')
            .pipe(takeUntilDestroyed())
            .subscribe(() => {
            this._accordion.setActiveItem(this);
        });
    }
    toggle(event) {
        event.preventDefault();
        this._accordion.toggleItem(this._item.id);
    }
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnAccordionTriggerDirective, isStandalone: true, selector: "[brnAccordionTrigger]", host: { attributes: { "role": "heading", "aria-level": "3" }, listeners: { "click": "toggle($event)", "keyup.space": "toggle($event)", "keyup.enter": "toggle($event)" }, properties: { "attr.data-state": "state()", "attr.aria-expanded": "state() === \"open\"", "attr.aria-controls": "ariaControls", "id": "id" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnAccordionTrigger]',
                    standalone: true,
                    host: {
                        '[attr.data-state]': 'state()',
                        '[attr.aria-expanded]': 'state() === "open"',
                        '[attr.aria-controls]': 'ariaControls',
                        role: 'heading',
                        'aria-level': '3',
                        '[id]': 'id',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { toggle: [{
                type: HostListener,
                args: ['click', ['$event']]
            }, {
                type: HostListener,
                args: ['keyup.space', ['$event']]
            }, {
                type: HostListener,
                args: ['keyup.enter', ['$event']]
            }] } });
const HORIZONTAL_KEYS_TO_PREVENT_DEFAULT = [
    'ArrowLeft',
    'ArrowRight',
    'PageDown',
    'PageUp',
    'Home',
    'End',
    ' ',
    'Enter',
];
const VERTICAL_KEYS_TO_PREVENT_DEFAULT = ['ArrowUp', 'ArrowDown', 'PageDown', 'PageUp', 'Home', 'End', ' ', 'Enter'];
class BrnAccordionDirective {
    _el = inject(ElementRef);
    _keyManager;
    _focusMonitor = inject(FocusMonitor);
    _focused = signal(false);
    _openItemIds = signal([]);
    openItemIds = this._openItemIds.asReadonly();
    state = computed(() => (this._openItemIds().length > 0 ? 'open' : 'closed'));
    triggers = contentChildren(BrnAccordionTriggerDirective, { descendants: true });
    type = input('single');
    dir = input(null);
    orientation = input('vertical');
    ngAfterContentInit() {
        this._keyManager = new FocusKeyManager(this.triggers())
            .withHomeAndEnd()
            .withPageUpDown()
            .withWrap();
        if (this.orientation() === 'horizontal') {
            this._keyManager.withHorizontalOrientation(this.dir() ?? 'ltr').withVerticalOrientation(false);
        }
        this._el.nativeElement.addEventListener('keydown', (event) => {
            const target = event.target;
            if (target.tagName === 'INPUT')
                return;
            this._keyManager?.onKeydown(event);
            this.preventDefaultEvents(event);
        });
        this._focusMonitor.monitor(this._el, true).subscribe((origin) => this._focused.set(origin !== null));
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._el);
    }
    setActiveItem(item) {
        this._keyManager?.setActiveItem(item);
    }
    toggleItem(id) {
        if (this._openItemIds().includes(id)) {
            this.closeItem(id);
            return;
        }
        this.openItem(id);
    }
    openItem(id) {
        if (this.type() === 'single') {
            this._openItemIds.set([id]);
            return;
        }
        this._openItemIds.update((ids) => [...ids, id]);
    }
    closeItem(id) {
        this._openItemIds.update((ids) => ids.filter((openId) => id !== openId));
    }
    preventDefaultEvents(event) {
        if (!this._focused())
            return;
        if (!('key' in event))
            return;
        const keys = this.orientation() === 'horizontal' ? HORIZONTAL_KEYS_TO_PREVENT_DEFAULT : VERTICAL_KEYS_TO_PREVENT_DEFAULT;
        if (keys.includes(event.key) && event.code !== 'NumpadEnter') {
            event.preventDefault();
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.8", type: BrnAccordionDirective, isStandalone: true, selector: "[brnAccordion]", inputs: { type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, dir: { classPropertyName: "dir", publicName: "dir", isSignal: true, isRequired: false, transformFunction: null }, orientation: { classPropertyName: "orientation", publicName: "orientation", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.data-state": "state()", "attr.data-orientation": "orientation()" } }, queries: [{ propertyName: "triggers", predicate: BrnAccordionTriggerDirective, descendants: true, isSignal: true }], exportAs: ["brnAccordion"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnAccordion]',
                    standalone: true,
                    host: {
                        '[attr.data-state]': 'state()',
                        '[attr.data-orientation]': 'orientation()',
                    },
                    exportAs: 'brnAccordion',
                }]
        }] });

class BrnAccordionContentComponent {
    _item = inject(BrnAccordionItemDirective);
    state = this._item.state;
    id = `brn-accordion-content-${this._item.id}`;
    ariaLabeledBy = `brn-accordion-trigger-${this._item.id}`;
    _addInert = computed(() => (this.state() === 'closed' ? true : undefined));
    _contentClass = signal('');
    constructor() {
        if (!this._item) {
            throw Error('Accordion Content can only be used inside an AccordionItem. Add brnAccordionItem to parent.');
        }
    }
    setClassToCustomElement(classes) {
        this._contentClass.set(classes);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.8", type: BrnAccordionContentComponent, isStandalone: true, selector: "brn-accordion-content", host: { attributes: { "role": "region" }, properties: { "attr.data-state": "state()", "attr.aria-labelledby": "ariaLabeledBy", "id": "id" } }, ngImport: i0, template: `
		<div [attr.inert]="_addInert()" style="overflow: hidden">
			<p [class]="_contentClass()">
				<ng-content />
			</p>
		</div>
	`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-accordion-content',
                    standalone: true,
                    host: {
                        '[attr.data-state]': 'state()',
                        '[attr.aria-labelledby]': 'ariaLabeledBy',
                        role: 'region',
                        '[id]': 'id',
                    },
                    template: `
		<div [attr.inert]="_addInert()" style="overflow: hidden">
			<p [class]="_contentClass()">
				<ng-content />
			</p>
		</div>
	`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }], ctorParameters: () => [] });

const BrnAccordionImports = [
    BrnAccordionDirective,
    BrnAccordionContentComponent,
    BrnAccordionItemDirective,
    BrnAccordionTriggerDirective,
];
class BrnAccordionModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionModule, imports: [BrnAccordionDirective,
            BrnAccordionContentComponent,
            BrnAccordionItemDirective,
            BrnAccordionTriggerDirective], exports: [BrnAccordionDirective,
            BrnAccordionContentComponent,
            BrnAccordionItemDirective,
            BrnAccordionTriggerDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAccordionModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnAccordionImports],
                    exports: [...BrnAccordionImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnAccordionContentComponent, BrnAccordionDirective, BrnAccordionImports, BrnAccordionItemDirective, BrnAccordionModule, BrnAccordionTriggerDirective };
//# sourceMappingURL=spartan-ng-brain-accordion.mjs.map
