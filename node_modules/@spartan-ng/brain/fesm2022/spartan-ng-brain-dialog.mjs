import * as i0 from '@angular/core';
import { inject, input, Directive, InjectionToken, RendererFactory2, Injector, signal, computed, runInInjectionContext, effect, Injectable, ViewContainerRef, output, booleanAttribute, untracked, numberAttribute, ViewEncapsulation, ChangeDetectionStrategy, Component, TemplateRef, NgModule } from '@angular/core';
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { Subject } from 'rxjs';
import { take, takeUntil, filter } from 'rxjs/operators';
import { provideExposesStateProviderExisting, provideCustomClassSettableExisting } from '@spartan-ng/brain/core';
import { OverlayPositionBuilder, ScrollStrategyOptions } from '@angular/cdk/overlay';
import { DIALOG_DATA, Dialog } from '@angular/cdk/dialog';

// brn-dialog-utils.ts
const cssClassesToArray = (classes, defaultClass = '') => {
    if (typeof classes === 'string') {
        const splitClasses = classes.trim().split(' ');
        if (splitClasses.length === 0) {
            return [defaultClass];
        }
        return splitClasses;
    }
    return classes ?? [];
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class BrnDialogRef {
    _cdkDialogRef;
    _open;
    state;
    dialogId;
    _options;
    _closing$ = new Subject();
    closing$ = this._closing$.asObservable();
    closed$;
    _previousTimeout;
    get open() {
        return this.state() === 'open';
    }
    constructor(_cdkDialogRef, _open, state, dialogId, _options) {
        this._cdkDialogRef = _cdkDialogRef;
        this._open = _open;
        this.state = state;
        this.dialogId = dialogId;
        this._options = _options;
        this.closed$ = this._cdkDialogRef.closed.pipe(take(1));
    }
    close(result, delay = this._options?.closeDelay ?? 0) {
        if (!this.open || this._options?.disableClose)
            return;
        this._closing$.next();
        this._open.set(false);
        if (this._previousTimeout) {
            clearTimeout(this._previousTimeout);
        }
        this._previousTimeout = setTimeout(() => {
            this._cdkDialogRef.close(result);
        }, delay);
    }
    setPanelClass(paneClass) {
        this._cdkDialogRef.config.panelClass = cssClassesToArray(paneClass);
    }
    setOverlayClass(overlayClass) {
        this._cdkDialogRef.config.backdropClass = cssClassesToArray(overlayClass);
    }
    setAriaDescribedBy(ariaDescribedBy) {
        this._cdkDialogRef.config.ariaDescribedBy = ariaDescribedBy;
    }
    setAriaLabelledBy(ariaLabelledBy) {
        this._cdkDialogRef.config.ariaLabelledBy = ariaLabelledBy;
    }
    setAriaLabel(ariaLabel) {
        this._cdkDialogRef.config.ariaLabel = ariaLabel;
    }
}

class BrnDialogCloseDirective {
    _brnDialogRef = inject(BrnDialogRef);
    delay = input(undefined, { transform: coerceNumberProperty });
    close() {
        this._brnDialogRef.close(undefined, this.delay());
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogCloseDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnDialogCloseDirective, isStandalone: true, selector: "button[brnDialogClose]", inputs: { delay: { classPropertyName: "delay", publicName: "delay", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "close()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'button[brnDialogClose]',
                    standalone: true,
                    host: {
                        '(click)': 'close()',
                    },
                }]
        }] });

const defaultOptions = {
    attachPositions: [],
    autoFocus: 'first-tabbable',
    closeDelay: 100,
    closeOnBackdropClick: true,
    closeOnOutsidePointerEvents: false,
    disableClose: false,
    hasBackdrop: true,
    positionStrategy: null,
    restoreFocus: true,
    role: 'dialog',
    scrollStrategy: null,
};
const BRN_DIALOG_DEFAULT_OPTIONS = new InjectionToken('brn-dialog-default-options', {
    providedIn: 'root',
    factory: () => defaultOptions,
});
function provideBrnDialogDefaultOptions(options) {
    return { provide: BRN_DIALOG_DEFAULT_OPTIONS, useValue: { ...defaultOptions, ...options } };
}
function injectBrnDialogDefaultOptions() {
    return inject(BRN_DIALOG_DEFAULT_OPTIONS, { optional: true }) ?? defaultOptions;
}

let dialogSequence = 0;
/** @deprecated `injectBrnDialogCtx` will no longer be supported once components are stable. Use `injectBrnDialogContext` instead.  */
const injectBrnDialogCtx = () => {
    return inject(DIALOG_DATA);
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const injectBrnDialogContext = (options = {}) => {
    return inject(DIALOG_DATA, options);
};
class BrnDialogService {
    _cdkDialog = inject(Dialog);
    _rendererFactory = inject(RendererFactory2);
    _renderer = this._rendererFactory.createRenderer(null, null);
    _positionBuilder = inject(OverlayPositionBuilder);
    _sso = inject(ScrollStrategyOptions);
    _injector = inject(Injector);
    open(content, vcr, context, options) {
        if (options?.id && this._cdkDialog.getDialogById(options.id)) {
            throw new Error(`Dialog with ID: ${options.id} already exists`);
        }
        const positionStrategy = options?.positionStrategy ??
            (options?.attachTo && options?.attachPositions && options?.attachPositions?.length > 0
                ? this._positionBuilder?.flexibleConnectedTo(options.attachTo).withPositions(options.attachPositions ?? [])
                : this._positionBuilder.global().centerHorizontally().centerVertically());
        let brnDialogRef;
        let effectRef;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const contextOrData = {
            ...context,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            close: (result = undefined) => brnDialogRef.close(result, options?.closeDelay),
        };
        const destroyed$ = new Subject();
        const open = signal(true);
        const state = computed(() => (open() ? 'open' : 'closed'));
        const dialogId = dialogSequence++;
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const cdkDialogRef = this._cdkDialog.open(content, {
            id: options?.id ?? `brn-dialog-${dialogId}`,
            role: options?.role,
            viewContainerRef: vcr,
            templateContext: () => ({
                $implicit: contextOrData,
            }),
            data: contextOrData,
            hasBackdrop: options?.hasBackdrop,
            panelClass: cssClassesToArray(options?.panelClass),
            backdropClass: cssClassesToArray(options?.backdropClass, 'bg-transparent'),
            positionStrategy,
            scrollStrategy: options?.scrollStrategy ?? this._sso?.block(),
            restoreFocus: options?.restoreFocus,
            disableClose: true,
            autoFocus: options?.autoFocus ?? 'first-tabbable',
            ariaDescribedBy: options?.ariaDescribedBy ?? `brn-dialog-description-${dialogId}`,
            ariaLabelledBy: options?.ariaLabelledBy ?? `brn-dialog-title-${dialogId}`,
            ariaLabel: options?.ariaLabel,
            ariaModal: options?.ariaModal,
            providers: (cdkDialogRef) => {
                brnDialogRef = new BrnDialogRef(cdkDialogRef, open, state, dialogId, options);
                runInInjectionContext(this._injector, () => {
                    effectRef = effect(() => {
                        if (overlay) {
                            this._renderer.setAttribute(overlay, 'data-state', state());
                        }
                        if (backdrop) {
                            this._renderer.setAttribute(backdrop, 'data-state', state());
                        }
                    });
                });
                const providers = [
                    {
                        provide: BrnDialogRef,
                        useValue: brnDialogRef,
                    },
                ];
                if (options?.providers) {
                    if (typeof options.providers === 'function') {
                        providers.push(...options.providers());
                    }
                    if (Array.isArray(options.providers)) {
                        providers.push(...options.providers);
                    }
                }
                return providers;
            },
        });
        const overlay = cdkDialogRef.overlayRef.overlayElement;
        const backdrop = cdkDialogRef.overlayRef.backdropElement;
        if (options?.closeOnOutsidePointerEvents) {
            cdkDialogRef.outsidePointerEvents.pipe(takeUntil(destroyed$)).subscribe(() => {
                brnDialogRef.close(undefined, options?.closeDelay);
            });
        }
        if (options?.closeOnBackdropClick) {
            cdkDialogRef.backdropClick.pipe(takeUntil(destroyed$)).subscribe(() => {
                brnDialogRef.close(undefined, options?.closeDelay);
            });
        }
        if (!options?.disableClose) {
            cdkDialogRef.keydownEvents
                .pipe(filter((e) => e.key === 'Escape'), takeUntil(destroyed$))
                .subscribe(() => {
                brnDialogRef.close(undefined, options?.closeDelay);
            });
        }
        cdkDialogRef.closed.pipe(takeUntil(destroyed$)).subscribe(() => {
            effectRef?.destroy();
            destroyed$.next();
        });
        return brnDialogRef;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class BrnDialogComponent {
    _dialogService = inject(BrnDialogService);
    _vcr = inject(ViewContainerRef);
    positionBuilder = inject(OverlayPositionBuilder);
    ssos = inject(ScrollStrategyOptions);
    _injector = inject(Injector);
    _defaultOptions = injectBrnDialogDefaultOptions();
    _context = {};
    stateComputed = computed(() => this._dialogRef()?.state() ?? 'closed');
    _contentTemplate;
    _dialogRef = signal(undefined);
    _dialogStateEffectRef;
    _backdropClass = signal(null);
    _panelClass = signal(null);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    closed = output();
    stateChanged = output();
    state = input(null);
    role = input(this._defaultOptions.role);
    hasBackdrop = input(this._defaultOptions.hasBackdrop, { transform: booleanAttribute });
    positionStrategy = input(this._defaultOptions.positionStrategy);
    mutablePositionStrategy = computed(() => signal(this.positionStrategy()));
    _positionStrategyState = computed(() => this.mutablePositionStrategy()());
    scrollStrategy = input(this._defaultOptions.scrollStrategy);
    _options = computed(() => {
        const scrollStrategyInput = this.scrollStrategy();
        let scrollStrategy;
        if (scrollStrategyInput === 'close') {
            scrollStrategy = this.ssos.close();
        }
        else if (scrollStrategyInput === 'reposition') {
            scrollStrategy = this.ssos.reposition();
        }
        else {
            scrollStrategy = scrollStrategyInput;
        }
        return {
            role: this.role(),
            hasBackdrop: this.hasBackdrop(),
            positionStrategy: this._positionStrategyState(),
            scrollStrategy,
            restoreFocus: this.restoreFocus(),
            closeOnOutsidePointerEvents: this._closeOnOutsidePointerEventsState(),
            closeOnBackdropClick: this.closeOnBackdropClick(),
            attachTo: this._attachToState(),
            attachPositions: this._attachPositionsState(),
            autoFocus: this.autoFocus(),
            closeDelay: this.closeDelay(),
            disableClose: this.disableClose(),
            backdropClass: this._backdropClass() ?? '',
            panelClass: this._panelClass() ?? '',
            ariaDescribedBy: this._ariaDescribedByState(),
            ariaLabelledBy: this._ariaLabelledByState(),
            ariaLabel: this._ariaLabelState(),
            ariaModal: this._ariaModalState(),
        };
    });
    constructor() {
        effect(() => {
            const state = this.state();
            if (state === 'open') {
                untracked(() => this.open());
            }
            if (state === 'closed') {
                untracked(() => this.close());
            }
        });
    }
    restoreFocus = input(this._defaultOptions.restoreFocus);
    closeOnOutsidePointerEvents = input(this._defaultOptions.closeOnOutsidePointerEvents, {
        transform: booleanAttribute,
    });
    mutableCloseOnOutsidePointerEvents = computed(() => signal(this.closeOnOutsidePointerEvents()));
    _closeOnOutsidePointerEventsState = computed(() => this.mutableCloseOnOutsidePointerEvents()());
    closeOnBackdropClick = input(this._defaultOptions.closeOnBackdropClick, {
        transform: booleanAttribute,
    });
    attachTo = input(null);
    mutableAttachTo = computed(() => signal(this.attachTo()));
    _attachToState = computed(() => this.mutableAttachTo()());
    attachPositions = input(this._defaultOptions.attachPositions);
    mutableAttachPositions = computed(() => signal(this.attachPositions()));
    _attachPositionsState = computed(() => this.mutableAttachPositions()());
    autoFocus = input(this._defaultOptions.autoFocus);
    closeDelay = input(this._defaultOptions.closeDelay, {
        transform: numberAttribute,
    });
    disableClose = input(this._defaultOptions.disableClose, { transform: booleanAttribute });
    ariaDescribedBy = input(null, {
        alias: 'aria-describedby',
    });
    _mutableAriaDescribedBy = computed(() => signal(this.ariaDescribedBy()));
    _ariaDescribedByState = computed(() => this._mutableAriaDescribedBy()());
    ariaLabelledBy = input(null, { alias: 'aria-labelledby' });
    _mutableAriaLabelledBy = computed(() => signal(this.ariaLabelledBy()));
    _ariaLabelledByState = computed(() => this._mutableAriaLabelledBy()());
    ariaLabel = input(null, { alias: 'aria-label' });
    _mutableAriaLabel = computed(() => signal(this.ariaLabel()));
    _ariaLabelState = computed(() => this._mutableAriaLabel()());
    ariaModal = input(true, { alias: 'aria-modal', transform: booleanAttribute });
    _mutableAriaModal = computed(() => signal(this.ariaModal()));
    _ariaModalState = computed(() => this._mutableAriaModal()());
    open() {
        if (!this._contentTemplate || this._dialogRef())
            return;
        this._dialogStateEffectRef?.destroy();
        const dialogRef = this._dialogService.open(this._contentTemplate, this._vcr, this._context, this._options());
        this._dialogRef.set(dialogRef);
        runInInjectionContext(this._injector, () => {
            this._dialogStateEffectRef = effect(() => {
                const state = dialogRef.state();
                untracked(() => this.stateChanged.emit(state));
            });
        });
        dialogRef.closed$.pipe(take(1)).subscribe((result) => {
            this._dialogRef.set(undefined);
            this.closed.emit(result);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    close(result, delay) {
        this._dialogRef()?.close(result, delay ?? this._options().closeDelay);
    }
    registerTemplate(template) {
        this._contentTemplate = template;
    }
    setOverlayClass(overlayClass) {
        this._backdropClass.set(overlayClass);
        this._dialogRef()?.setOverlayClass(overlayClass);
    }
    setPanelClass(panelClass) {
        this._panelClass.set(panelClass ?? '');
        this._dialogRef()?.setPanelClass(panelClass);
    }
    setContext(context) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        this._context = { ...this._context, ...context };
    }
    setAriaDescribedBy(ariaDescribedBy) {
        this._mutableAriaDescribedBy().set(ariaDescribedBy);
        this._dialogRef()?.setAriaDescribedBy(ariaDescribedBy);
    }
    setAriaLabelledBy(ariaLabelledBy) {
        this._mutableAriaLabelledBy().set(ariaLabelledBy);
        this._dialogRef()?.setAriaLabelledBy(ariaLabelledBy);
    }
    setAriaLabel(ariaLabel) {
        this._mutableAriaLabel().set(ariaLabel);
        this._dialogRef()?.setAriaLabel(ariaLabel);
    }
    setAriaModal(ariaModal) {
        this._mutableAriaModal().set(ariaModal);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.8", type: BrnDialogComponent, isStandalone: true, selector: "brn-dialog", inputs: { state: { classPropertyName: "state", publicName: "state", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null }, hasBackdrop: { classPropertyName: "hasBackdrop", publicName: "hasBackdrop", isSignal: true, isRequired: false, transformFunction: null }, positionStrategy: { classPropertyName: "positionStrategy", publicName: "positionStrategy", isSignal: true, isRequired: false, transformFunction: null }, scrollStrategy: { classPropertyName: "scrollStrategy", publicName: "scrollStrategy", isSignal: true, isRequired: false, transformFunction: null }, restoreFocus: { classPropertyName: "restoreFocus", publicName: "restoreFocus", isSignal: true, isRequired: false, transformFunction: null }, closeOnOutsidePointerEvents: { classPropertyName: "closeOnOutsidePointerEvents", publicName: "closeOnOutsidePointerEvents", isSignal: true, isRequired: false, transformFunction: null }, closeOnBackdropClick: { classPropertyName: "closeOnBackdropClick", publicName: "closeOnBackdropClick", isSignal: true, isRequired: false, transformFunction: null }, attachTo: { classPropertyName: "attachTo", publicName: "attachTo", isSignal: true, isRequired: false, transformFunction: null }, attachPositions: { classPropertyName: "attachPositions", publicName: "attachPositions", isSignal: true, isRequired: false, transformFunction: null }, autoFocus: { classPropertyName: "autoFocus", publicName: "autoFocus", isSignal: true, isRequired: false, transformFunction: null }, closeDelay: { classPropertyName: "closeDelay", publicName: "closeDelay", isSignal: true, isRequired: false, transformFunction: null }, disableClose: { classPropertyName: "disableClose", publicName: "disableClose", isSignal: true, isRequired: false, transformFunction: null }, ariaDescribedBy: { classPropertyName: "ariaDescribedBy", publicName: "aria-describedby", isSignal: true, isRequired: false, transformFunction: null }, ariaLabelledBy: { classPropertyName: "ariaLabelledBy", publicName: "aria-labelledby", isSignal: true, isRequired: false, transformFunction: null }, ariaLabel: { classPropertyName: "ariaLabel", publicName: "aria-label", isSignal: true, isRequired: false, transformFunction: null }, ariaModal: { classPropertyName: "ariaModal", publicName: "aria-modal", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { closed: "closed", stateChanged: "stateChanged" }, exportAs: ["brnDialog"], ngImport: i0, template: `
		<ng-content />
	`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-dialog',
                    standalone: true,
                    template: `
		<ng-content />
	`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    exportAs: 'brnDialog',
                }]
        }], ctorParameters: () => [] });

class BrnDialogContentDirective {
    _brnDialog = inject(BrnDialogComponent, { optional: true });
    _brnDialogRef = inject(BrnDialogRef, { optional: true });
    _template = inject(TemplateRef);
    state = computed(() => this._brnDialog?.stateComputed() ?? this._brnDialogRef?.state() ?? 'closed');
    className = input(undefined, { alias: 'class' });
    context = input(undefined);
    constructor() {
        if (!this._brnDialog)
            return;
        this._brnDialog.registerTemplate(this._template);
        effect(() => {
            const context = this.context();
            if (!this._brnDialog || !context)
                return;
            untracked(() => this._brnDialog?.setContext(context));
        });
        effect(() => {
            if (!this._brnDialog)
                return;
            const newClass = this.className();
            untracked(() => this._brnDialog?.setPanelClass(newClass));
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogContentDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnDialogContentDirective, isStandalone: true, selector: "[brnDialogContent]", inputs: { className: { classPropertyName: "className", publicName: "class", isSignal: true, isRequired: false, transformFunction: null }, context: { classPropertyName: "context", publicName: "context", isSignal: true, isRequired: false, transformFunction: null } }, providers: [provideExposesStateProviderExisting((() => BrnDialogContentDirective))], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogContentDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnDialogContent]',
                    standalone: true,
                    providers: [provideExposesStateProviderExisting((() => BrnDialogContentDirective))],
                }]
        }], ctorParameters: () => [] });

class BrnDialogDescriptionDirective {
    _brnDialogRef = inject(BrnDialogRef);
    _id = signal(`brn-dialog-description-${this._brnDialogRef?.dialogId}`);
    constructor() {
        effect(() => {
            this._brnDialogRef.setAriaDescribedBy(this._id());
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogDescriptionDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnDialogDescriptionDirective, isStandalone: true, selector: "[brnDialogDescription]", host: { properties: { "id": "_id()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogDescriptionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnDialogDescription]',
                    standalone: true,
                    host: {
                        '[id]': '_id()',
                    },
                }]
        }], ctorParameters: () => [] });

class BrnDialogOverlayComponent {
    _brnDialog = inject(BrnDialogComponent);
    className = input(undefined, { alias: 'class' });
    setClassToCustomElement(newClass) {
        this._brnDialog.setOverlayClass(newClass);
    }
    constructor() {
        effect(() => {
            if (!this._brnDialog)
                return;
            const newClass = this.className();
            untracked(() => this._brnDialog.setOverlayClass(newClass));
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogOverlayComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.8", type: BrnDialogOverlayComponent, isStandalone: true, selector: "brn-dialog-overlay", inputs: { className: { classPropertyName: "className", publicName: "class", isSignal: true, isRequired: false, transformFunction: null } }, providers: [provideCustomClassSettableExisting((() => BrnDialogOverlayComponent))], ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogOverlayComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-dialog-overlay',
                    standalone: true,
                    template: '',
                    providers: [provideCustomClassSettableExisting((() => BrnDialogOverlayComponent))],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }], ctorParameters: () => [] });

class BrnDialogTitleDirective {
    _brnDialogRef = inject(BrnDialogRef);
    _id = signal(`brn-dialog-title-${this._brnDialogRef?.dialogId}`);
    constructor() {
        effect(() => {
            this._brnDialogRef.setAriaLabelledBy(this._id());
        });
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnDialogTitleDirective, isStandalone: true, selector: "[brnDialogTitle]", host: { properties: { "id": "_id()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnDialogTitle]',
                    standalone: true,
                    host: {
                        '[id]': '_id()',
                    },
                }]
        }], ctorParameters: () => [] });

let idSequence = 0;
class BrnDialogTriggerDirective {
    _brnDialog = inject(BrnDialogComponent, { optional: true });
    _brnDialogRef = inject(BrnDialogRef, { optional: true });
    id = input(`brn-dialog-trigger-${idSequence++}`);
    state = this._brnDialogRef?.state ?? signal('closed');
    dialogId = `brn-dialog-${this._brnDialogRef?.dialogId ?? idSequence++}`;
    brnDialogTriggerFor = input(undefined, {
        alias: 'brnDialogTriggerFor',
    });
    mutableBrnDialogTriggerFor = computed(() => signal(this.brnDialogTriggerFor()));
    brnDialogTriggerForState = computed(() => this.mutableBrnDialogTriggerFor()());
    constructor() {
        effect(() => {
            const brnDialog = this.brnDialogTriggerForState();
            if (!brnDialog)
                return;
            this._brnDialog = brnDialog;
        });
    }
    open() {
        this._brnDialog?.open();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogTriggerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnDialogTriggerDirective, isStandalone: true, selector: "button[brnDialogTrigger],button[brnDialogTriggerFor]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, brnDialogTriggerFor: { classPropertyName: "brnDialogTriggerFor", publicName: "brnDialogTriggerFor", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "aria-haspopup": "dialog" }, listeners: { "click": "open()" }, properties: { "id": "id()", "attr.aria-expanded": "state() === 'open' ? 'true': 'false'", "attr.data-state": "state()", "attr.aria-controls": "dialogId" } }, exportAs: ["brnDialogTrigger"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'button[brnDialogTrigger],button[brnDialogTriggerFor]',
                    standalone: true,
                    host: {
                        '[id]': 'id()',
                        '(click)': 'open()',
                        'aria-haspopup': 'dialog',
                        '[attr.aria-expanded]': "state() === 'open' ? 'true': 'false'",
                        '[attr.data-state]': 'state()',
                        '[attr.aria-controls]': 'dialogId',
                    },
                    exportAs: 'brnDialogTrigger',
                }]
        }], ctorParameters: () => [] });

const DEFAULT_BRN_DIALOG_OPTIONS = {
    role: 'dialog',
    attachPositions: [],
    attachTo: null,
    autoFocus: 'first-tabbable',
    backdropClass: '',
    closeDelay: 100,
    closeOnBackdropClick: true,
    closeOnOutsidePointerEvents: false,
    hasBackdrop: true,
    panelClass: '',
    positionStrategy: null,
    restoreFocus: true,
    scrollStrategy: null,
    disableClose: false,
    ariaLabel: undefined,
    ariaModal: true,
};

const BrnDialogImports = [
    BrnDialogComponent,
    BrnDialogOverlayComponent,
    BrnDialogTriggerDirective,
    BrnDialogCloseDirective,
    BrnDialogContentDirective,
    BrnDialogTitleDirective,
    BrnDialogDescriptionDirective,
];
class BrnDialogModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogModule, imports: [BrnDialogComponent,
            BrnDialogOverlayComponent,
            BrnDialogTriggerDirective,
            BrnDialogCloseDirective,
            BrnDialogContentDirective,
            BrnDialogTitleDirective,
            BrnDialogDescriptionDirective], exports: [BrnDialogComponent,
            BrnDialogOverlayComponent,
            BrnDialogTriggerDirective,
            BrnDialogCloseDirective,
            BrnDialogContentDirective,
            BrnDialogTitleDirective,
            BrnDialogDescriptionDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnDialogModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnDialogImports],
                    exports: [...BrnDialogImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnDialogCloseDirective, BrnDialogComponent, BrnDialogContentDirective, BrnDialogDescriptionDirective, BrnDialogImports, BrnDialogModule, BrnDialogOverlayComponent, BrnDialogRef, BrnDialogService, BrnDialogTitleDirective, BrnDialogTriggerDirective, DEFAULT_BRN_DIALOG_OPTIONS, cssClassesToArray, defaultOptions, injectBrnDialogContext, injectBrnDialogCtx, injectBrnDialogDefaultOptions, provideBrnDialogDefaultOptions };
//# sourceMappingURL=spartan-ng-brain-dialog.mjs.map
