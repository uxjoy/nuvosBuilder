import * as i0 from '@angular/core';
import { InjectionToken, inject, ElementRef, input, computed, Directive, HostListener, ViewContainerRef, ChangeDetectorRef, TemplateRef, effect, untracked, Injector, booleanAttribute, model, numberAttribute, contentChild, contentChildren, signal, afterNextRender, NgModule } from '@angular/core';
import { injectDateAdapter } from '@spartan-ng/brain/date-time';

const BrnCalendarToken = new InjectionToken('BrnCalendarToken');
function provideBrnCalendar(instance) {
    return { provide: BrnCalendarToken, useExisting: instance };
}
/**
 * Inject the calendar component.
 */
function injectBrnCalendar() {
    return inject(BrnCalendarToken);
}

class BrnCalendarCellButtonDirective {
    /** Access the date adapter */
    dateAdapter = injectDateAdapter();
    /** Access the calendar component */
    calendar = injectBrnCalendar();
    /** Access the element ref */
    _elementRef = inject(ElementRef);
    /** The date this cell represents */
    date = input.required();
    /** Whether this date is currently selected */
    selected = computed(() => this.calendar.isSelected(this.date()));
    /** Whether this date is focusable */
    focusable = computed(() => this.dateAdapter.isSameDay(this.calendar.focusedDate(), this.date()));
    outside = computed(() => {
        const focusedDate = this.calendar.focusedDate();
        return !this.dateAdapter.isSameMonth(this.date(), focusedDate);
    });
    /** Whether this date is today */
    today = computed(() => this.dateAdapter.isSameDay(this.date(), this.dateAdapter.now()));
    /** Whether this date is disabled */
    disabled = computed(() => this.calendar.isDateDisabled(this.date()) || this.calendar.disabled());
    /**
     * Focus the previous cell.
     */
    focusPrevious(event) {
        event.preventDefault();
        event.stopPropagation();
        // in rtl, the arrow keys are reversed.
        const targetDate = this.dateAdapter.add(this.calendar.focusedDate(), {
            days: this.getDirection() === 'rtl' ? 1 : -1,
        });
        this.calendar.setFocusedDate(targetDate);
    }
    /**
     * Focus the next cell.
     */
    focusNext(event) {
        event.preventDefault();
        event.stopPropagation();
        const targetDate = this.dateAdapter.add(this.calendar.focusedDate(), {
            days: this.getDirection() === 'rtl' ? -1 : 1,
        });
        this.calendar.setFocusedDate(targetDate);
    }
    /**
     * Focus the above cell.
     */
    focusAbove(event) {
        event.preventDefault();
        event.stopPropagation();
        this.calendar.setFocusedDate(this.dateAdapter.subtract(this.calendar.focusedDate(), { days: 7 }));
    }
    /**
     * Focus the below cell.
     */
    focusBelow(event) {
        event.preventDefault();
        event.stopPropagation();
        this.calendar.setFocusedDate(this.dateAdapter.add(this.calendar.focusedDate(), { days: 7 }));
    }
    /**
     * Focus the first date of the month.
     */
    focusFirst(event) {
        event.preventDefault();
        event.stopPropagation();
        this.calendar.setFocusedDate(this.dateAdapter.startOfMonth(this.calendar.focusedDate()));
    }
    /**
     * Focus the last date of the month.
     */
    focusLast(event) {
        event.preventDefault();
        event.stopPropagation();
        this.calendar.setFocusedDate(this.dateAdapter.endOfMonth(this.calendar.focusedDate()));
    }
    /**
     * Focus the same date in the previous month.
     */
    focusPreviousMonth(event) {
        event.preventDefault();
        event.stopPropagation();
        const date = this.dateAdapter.getDate(this.calendar.focusedDate());
        let previousMonthTarget = this.dateAdapter.startOfMonth(this.calendar.focusedDate());
        previousMonthTarget = this.dateAdapter.subtract(previousMonthTarget, { months: 1 });
        const lastDay = this.dateAdapter.endOfMonth(previousMonthTarget);
        // if we are on a date that does not exist in the previous month, we should focus the last day of the month.
        if (date > this.dateAdapter.getDate(lastDay)) {
            this.calendar.setFocusedDate(lastDay);
        }
        else {
            this.calendar.setFocusedDate(this.dateAdapter.set(previousMonthTarget, { day: date }));
        }
    }
    /**
     * Focus the same date in the next month.
     */
    focusNextMonth(event) {
        event.preventDefault();
        event.stopPropagation();
        const date = this.dateAdapter.getDate(this.calendar.focusedDate());
        let nextMonthTarget = this.dateAdapter.startOfMonth(this.calendar.focusedDate());
        nextMonthTarget = this.dateAdapter.add(nextMonthTarget, { months: 1 });
        const lastDay = this.dateAdapter.endOfMonth(nextMonthTarget);
        // if we are on a date that does not exist in the next month, we should focus the last day of the month.
        if (date > this.dateAdapter.getDate(lastDay)) {
            this.calendar.setFocusedDate(lastDay);
        }
        else {
            this.calendar.setFocusedDate(this.dateAdapter.set(nextMonthTarget, { day: date }));
        }
    }
    /**
     * Get the direction of the element.
     */
    getDirection() {
        return getComputedStyle(this._elementRef.nativeElement).direction === 'rtl' ? 'rtl' : 'ltr';
    }
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarCellButtonDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnCalendarCellButtonDirective, isStandalone: true, selector: "button[brnCalendarCellButton]", inputs: { date: { classPropertyName: "date", publicName: "date", isSignal: true, isRequired: true, transformFunction: null } }, host: { attributes: { "role": "gridcell", "type": "button" }, listeners: { "click": "calendar.selectDate(date())", "keydown.arrowLeft": "focusPrevious($event)", "keydown.arrowRight": "focusNext($event)", "keydown.arrowUp": "focusAbove($event)", "keydown.arrowDown": "focusBelow($event)", "keydown.home": "focusFirst($event)", "keydown.end": "focusLast($event)", "keydown.pageUp": "focusPreviousMonth($event)", "keydown.pageDown": "focusNextMonth($event)" }, properties: { "tabindex": "focusable() ? 0 : -1", "attr.data-outside": "outside() ? '' : null", "attr.data-today": "today() && !selected() ? '' : null", "attr.data-selected": "selected() ? '' : null", "attr.data-disabled": "disabled() ? '' : null", "attr.aria-selected": "selected() ? 'true' : null", "attr.aria-disabled": "disabled() ? 'true' : null", "disabled": "disabled()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarCellButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'button[brnCalendarCellButton]',
                    standalone: true,
                    host: {
                        role: 'gridcell',
                        '[tabindex]': 'focusable() ? 0 : -1',
                        type: 'button',
                        '[attr.data-outside]': "outside() ? '' : null",
                        '[attr.data-today]': "today() && !selected() ? '' : null",
                        '[attr.data-selected]': "selected() ? '' : null",
                        '[attr.data-disabled]': "disabled() ? '' : null",
                        '[attr.aria-selected]': "selected() ? 'true' : null",
                        '[attr.aria-disabled]': "disabled() ? 'true' : null",
                        '[disabled]': 'disabled()',
                        '(click)': 'calendar.selectDate(date())',
                        '(keydown.arrowLeft)': 'focusPrevious($event)',
                        '(keydown.arrowRight)': 'focusNext($event)',
                        '(keydown.arrowUp)': 'focusAbove($event)',
                        '(keydown.arrowDown)': 'focusBelow($event)',
                        '(keydown.home)': 'focusFirst($event)',
                        '(keydown.end)': 'focusLast($event)',
                        '(keydown.pageUp)': 'focusPreviousMonth($event)',
                        '(keydown.pageDown)': 'focusNextMonth($event)',
                    },
                }]
        }] });

class BrnCalendarCellDirective {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarCellDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnCalendarCellDirective, isStandalone: true, selector: "[brnCalendarCell]", host: { attributes: { "role": "presentation" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarCellDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCalendarCell]',
                    standalone: true,
                    host: {
                        role: 'presentation',
                    },
                }]
        }] });

class BrnCalendarGridDirective {
    /** Access the calendar component */
    calendar = injectBrnCalendar();
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarGridDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnCalendarGridDirective, isStandalone: true, selector: "[brnCalendarGrid]", host: { attributes: { "role": "grid" }, properties: { "attr.aria-labelledby": "calendar.header()?.id()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarGridDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCalendarGrid]',
                    standalone: true,
                    host: {
                        role: 'grid',
                        '[attr.aria-labelledby]': 'calendar.header()?.id()',
                    },
                }]
        }] });

let uniqueId = 0;
class BrnCalendarHeaderDirective {
    /** The unique id for the header */
    id = input(`brn-calendar-header-${uniqueId++}`);
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarHeaderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnCalendarHeaderDirective, isStandalone: true, selector: "[brnCalendarHeader]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "aria-live": "polite", "role": "presentation" }, properties: { "id": "id()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarHeaderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCalendarHeader]',
                    standalone: true,
                    host: {
                        '[id]': 'id()',
                        'aria-live': 'polite',
                        role: 'presentation',
                    },
                }]
        }] });

const BrnCalendarI18nToken = new InjectionToken('BrnCalendarI18nToken');
/**
 * Provide the calendar i18n configuration.
 */
function provideBrnCalendarI18n(configuration) {
    return { provide: BrnCalendarI18nToken, useValue: configuration };
}
const defaultCalendarI18n = {
    formatWeekdayName: (index) => {
        const weekdays = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
        return weekdays[index];
    },
    formatHeader: (month, year) => {
        return new Date(year, month).toLocaleDateString(undefined, {
            month: 'long',
            year: 'numeric',
        });
    },
    labelPrevious: () => 'Go to the previous month',
    labelNext: () => 'Go to the next month',
    labelWeekday: (index) => {
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        return weekdays[index];
    },
};
/**
 * Inject the calendar i18n configuration.
 */
function injectBrnCalendarI18n() {
    return inject(BrnCalendarI18nToken, { optional: true }) ?? defaultCalendarI18n;
}

class BrnCalendarNextButtonDirective {
    /** Access the calendar */
    _calendar = injectBrnCalendar();
    /** Access the date adapter */
    _dateAdapter = injectDateAdapter();
    /** Access the calendar i18n */
    i18n = injectBrnCalendarI18n();
    /** Focus the previous month */
    focusPreviousMonth() {
        const targetDate = this._dateAdapter.add(this._calendar.state().focusedDate(), { months: 1 });
        // if the date is disabled, but there are available dates in the month, focus the last day of the month.
        const possibleDate = this._calendar.constrainDate(targetDate);
        if (this._dateAdapter.isSameMonth(possibleDate, targetDate)) {
            // if this date is within the same month, then focus it
            this._calendar.state().focusedDate.set(possibleDate);
            return;
        }
        this._calendar.state().focusedDate.set(targetDate);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarNextButtonDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnCalendarNextButtonDirective, isStandalone: true, selector: "[brnCalendarNextButton]", host: { attributes: { "type": "button" }, listeners: { "click": "focusPreviousMonth()" }, properties: { "attr.aria-label": "i18n.labelNext()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarNextButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCalendarNextButton]',
                    standalone: true,
                    host: {
                        type: 'button',
                        '[attr.aria-label]': 'i18n.labelNext()',
                    },
                }]
        }], propDecorators: { focusPreviousMonth: [{
                type: HostListener,
                args: ['click']
            }] } });

class BrnCalendarPreviousButtonDirective {
    /** Access the calendar */
    _calendar = injectBrnCalendar();
    /** Access the date adapter */
    _dateAdapter = injectDateAdapter();
    /** Access the calendar i18n */
    i18n = injectBrnCalendarI18n();
    /** Focus the previous month */
    focusPreviousMonth() {
        const targetDate = this._dateAdapter.subtract(this._calendar.state().focusedDate(), { months: 1 });
        // if the date is disabled, but there are available dates in the month, focus the last day of the month.
        const possibleDate = this._calendar.constrainDate(targetDate);
        if (this._dateAdapter.isSameMonth(possibleDate, targetDate)) {
            // if this date is within the same month, then focus it
            this._calendar.state().focusedDate.set(possibleDate);
            return;
        }
        this._calendar.state().focusedDate.set(targetDate);
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarPreviousButtonDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnCalendarPreviousButtonDirective, isStandalone: true, selector: "[brnCalendarPreviousButton]", host: { attributes: { "type": "button" }, listeners: { "click": "focusPreviousMonth()" }, properties: { "attr.aria-label": "i18n.labelPrevious()" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarPreviousButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCalendarPreviousButton]',
                    standalone: true,
                    host: {
                        type: 'button',
                        '[attr.aria-label]': 'i18n.labelPrevious()',
                    },
                }]
        }], propDecorators: { focusPreviousMonth: [{
                type: HostListener,
                args: ['click']
            }] } });

class BrnCalendarWeekDirective {
    /** Access the calendar */
    _calendar = injectBrnCalendar();
    /** Access the view container ref */
    _viewContainerRef = inject(ViewContainerRef);
    /** Access the change detector */
    _changeDetector = inject(ChangeDetectorRef);
    /** Access the template ref */
    _templateRef = inject(TemplateRef);
    // get the weeks to display.
    weeks = computed(() => {
        const days = this._calendar.days();
        const weeks = [];
        for (let i = 0; i < days.length; i += 7) {
            weeks.push(days.slice(i, i + 7));
        }
        return weeks;
    });
    /** Store the view refs */
    _viewRefs = [];
    // Make sure the template checker knows the type of the context with which the
    // template of this directive will be rendered
    static ngTemplateContextGuard(_, ctx) {
        return true;
    }
    constructor() {
        // this should use `afterRenderEffect` but it's not available in the current version
        effect(() => {
            const weeks = this.weeks();
            untracked(() => this._renderWeeks(weeks));
        });
    }
    _renderWeeks(weeks) {
        // Destroy all the views when the directive is destroyed
        for (const viewRef of this._viewRefs) {
            viewRef.destroy();
        }
        this._viewRefs.length = 0;
        // Create a new view for each week
        for (const week of weeks) {
            const viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, {
                $implicit: week,
            });
            this._viewRefs.push(viewRef);
        }
        this._changeDetector.detectChanges();
    }
    ngOnDestroy() {
        // Destroy all the views when the directive is destroyed
        for (const viewRef of this._viewRefs) {
            viewRef.destroy();
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarWeekDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnCalendarWeekDirective, isStandalone: true, selector: "[brnCalendarWeek]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarWeekDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[brnCalendarWeek]',
                }]
        }], ctorParameters: () => [] });

class BrnCalendarWeekdayDirective {
    /** Access the calendar */
    _calendar = injectBrnCalendar();
    /** Access the date time adapter */
    _dateAdapter = injectDateAdapter();
    /** Access the view container ref */
    _viewContainerRef = inject(ViewContainerRef);
    /** Access the template ref */
    _templateRef = inject(TemplateRef);
    /** Get the days of the week to display in the header. */
    weekdays = computed(() => this._calendar.days().slice(0, 7));
    /** Store the view refs */
    _viewRefs = [];
    // Make sure the template checker knows the type of the context with which the
    // template of this directive will be rendered
    static ngTemplateContextGuard(_, ctx) {
        return true;
    }
    constructor() {
        // Create a new view for each day
        for (const day of this.weekdays()) {
            const viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, {
                $implicit: this._dateAdapter.getDay(day),
            });
            this._viewRefs.push(viewRef);
        }
    }
    ngOnDestroy() {
        // Destroy all the views when the directive is destroyed
        for (const viewRef of this._viewRefs) {
            viewRef.destroy();
        }
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarWeekdayDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnCalendarWeekdayDirective, isStandalone: true, selector: "[brnCalendarWeekday]", ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarWeekdayDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[brnCalendarWeekday]',
                }]
        }], ctorParameters: () => [] });

class BrnCalendarDirective {
    /** Access the date adapter */
    dateAdapter = injectDateAdapter();
    /** Access the change detector */
    _changeDetector = inject(ChangeDetectorRef);
    /** Access the injector */
    _injector = inject(Injector);
    /** The minimum date that can be selected.*/
    min = input();
    /** The maximum date that can be selected. */
    max = input();
    /** Determine if the date picker is disabled. */
    disabled = input(false, {
        transform: booleanAttribute,
    });
    /** The selected value. */
    date = model();
    /** Whether a specific date is disabled. */
    dateDisabled = input(() => false);
    /** The day the week starts on */
    weekStartsOn = input(0, {
        transform: (v) => numberAttribute(v),
    });
    /** The default focused date. */
    defaultFocusedDate = input();
    /** @internal Access the header */
    header = contentChild(BrnCalendarHeaderDirective);
    /** Store the cells */
    cells = contentChildren(BrnCalendarCellButtonDirective, {
        descendants: true,
    });
    /**
     * @internal
     * The internal state of the component.
     */
    state = computed(() => ({
        focusedDate: signal(this.constrainDate(this.defaultFocusedDate() ?? this.date() ?? this.dateAdapter.now())),
    }));
    /**
     * The focused date.
     */
    focusedDate = computed(() => this.state().focusedDate());
    /**
     * Get all the days to display, this is the days of the current month
     * and the days of the previous and next month to fill the grid.
     */
    days = computed(() => {
        const weekStartsOn = this.weekStartsOn();
        const month = this.state().focusedDate();
        const days = [];
        // Get the first and last day of the month.
        let firstDay = this.dateAdapter.startOfMonth(month);
        let lastDay = this.dateAdapter.endOfMonth(month);
        // we need to subtract until we get the to starting day before or on the start of the month.
        while (this.dateAdapter.getDay(firstDay) !== weekStartsOn) {
            firstDay = this.dateAdapter.subtract(firstDay, { days: 1 });
        }
        const weekEndsOn = (weekStartsOn + 6) % 7;
        // we need to add until we get to the ending day after or on the end of the month.
        while (this.dateAdapter.getDay(lastDay) !== weekEndsOn) {
            lastDay = this.dateAdapter.add(lastDay, { days: 1 });
        }
        // collect all the days to display.
        while (firstDay <= lastDay) {
            days.push(firstDay);
            firstDay = this.dateAdapter.add(firstDay, { days: 1 });
        }
        return days;
    });
    /** @internal Constrain a date to the min and max boundaries */
    constrainDate(date) {
        const min = this.min();
        const max = this.max();
        // If there is no min or max, return the date.
        if (!min && !max) {
            return date;
        }
        // If there is a min and the date is before the min, return the min.
        if (min && this.dateAdapter.isBefore(date, this.dateAdapter.startOfDay(min))) {
            return min;
        }
        // If there is a max and the date is after the max, return the max.
        if (max && this.dateAdapter.isAfter(date, this.dateAdapter.endOfDay(max))) {
            return max;
        }
        // Return the date.
        return date;
    }
    /** @internal Determine if a date is disabled */
    isDateDisabled(date) {
        // if the calendar is disabled we can't select this date
        if (this.disabled()) {
            return true;
        }
        // if the date is outside the min and max range
        const min = this.min();
        const max = this.max();
        if (min && this.dateAdapter.isBefore(date, this.dateAdapter.startOfDay(min))) {
            return true;
        }
        if (max && this.dateAdapter.isAfter(date, this.dateAdapter.endOfDay(max))) {
            return true;
        }
        // if this specific date is disabled
        const disabledFn = this.dateDisabled();
        if (disabledFn(date)) {
            return true;
        }
        return false;
    }
    isSelected(date) {
        const selected = this.date();
        return selected !== undefined && this.dateAdapter.isSameDay(date, selected);
    }
    selectDate(date) {
        if (this.isSelected(date)) {
            this.date.set(undefined);
        }
        else {
            this.date.set(date);
        }
        this.state().focusedDate.set(date);
    }
    /** @internal Set the focused date */
    setFocusedDate(date) {
        // check if the date is disabled.
        if (this.isDateDisabled(date)) {
            return;
        }
        this.state().focusedDate.set(date);
        // wait until the cells have all updated
        afterNextRender({
            write: () => {
                // focus the cell with the target date.
                const cell = this.cells().find((c) => this.dateAdapter.isSameDay(c.date(), date));
                if (cell) {
                    cell.focus();
                }
            },
        }, {
            injector: this._injector,
        });
        // we must update the view to ensure the focused cell is visible.
        this._changeDetector.detectChanges();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.8", type: BrnCalendarDirective, isStandalone: true, selector: "[brnCalendar]", inputs: { min: { classPropertyName: "min", publicName: "min", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "max", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, date: { classPropertyName: "date", publicName: "date", isSignal: true, isRequired: false, transformFunction: null }, dateDisabled: { classPropertyName: "dateDisabled", publicName: "dateDisabled", isSignal: true, isRequired: false, transformFunction: null }, weekStartsOn: { classPropertyName: "weekStartsOn", publicName: "weekStartsOn", isSignal: true, isRequired: false, transformFunction: null }, defaultFocusedDate: { classPropertyName: "defaultFocusedDate", publicName: "defaultFocusedDate", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { date: "dateChange" }, providers: [provideBrnCalendar(BrnCalendarDirective)], queries: [{ propertyName: "header", first: true, predicate: BrnCalendarHeaderDirective, descendants: true, isSignal: true }, { propertyName: "cells", predicate: BrnCalendarCellButtonDirective, descendants: true, isSignal: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCalendar]',
                    standalone: true,
                    providers: [provideBrnCalendar(BrnCalendarDirective)],
                }]
        }] });

class BrnCalendarMultiDirective {
    // /** Access the date adapter */
    dateAdapter = injectDateAdapter();
    /** Access the change detector */
    _changeDetector = inject(ChangeDetectorRef);
    /** Access the injector */
    _injector = inject(Injector);
    /** The minimum date that can be selected.*/
    min = input();
    /** The maximum date that can be selected. */
    max = input();
    /** The minimum selectable dates.  */
    minSelection = input(undefined, {
        transform: numberAttribute,
    });
    /** The maximum selectable dates.  */
    maxSelection = input(undefined, {
        transform: numberAttribute,
    });
    /** Determine if the date picker is disabled. */
    disabled = input(false, {
        transform: booleanAttribute,
    });
    /** The selected value. */
    date = model();
    /** Whether a specific date is disabled. */
    dateDisabled = input(() => false);
    /** The day the week starts on */
    weekStartsOn = input(0, {
        transform: (v) => numberAttribute(v),
    });
    /** The default focused date. */
    defaultFocusedDate = input();
    /** @internal Access the header */
    header = contentChild(BrnCalendarHeaderDirective);
    /** Store the cells */
    cells = contentChildren(BrnCalendarCellButtonDirective, {
        descendants: true,
    });
    /**
     * @internal
     * The internal state of the component.
     */
    state = computed(() => ({
        focusedDate: signal(this.constrainDate(this.defaultFocusedDate() ?? this.dateAdapter.now())),
    }));
    /**
     * The focused date.
     */
    focusedDate = computed(() => this.state().focusedDate());
    /**
     * Get all the days to display, this is the days of the current month
     * and the days of the previous and next month to fill the grid.
     */
    days = computed(() => {
        const weekStartsOn = this.weekStartsOn();
        const month = this.state().focusedDate();
        const days = [];
        // Get the first and last day of the month.
        let firstDay = this.dateAdapter.startOfMonth(month);
        let lastDay = this.dateAdapter.endOfMonth(month);
        // we need to subtract until we get the to starting day before or on the start of the month.
        while (this.dateAdapter.getDay(firstDay) !== weekStartsOn) {
            firstDay = this.dateAdapter.subtract(firstDay, { days: 1 });
        }
        const weekEndsOn = (weekStartsOn + 6) % 7;
        // we need to add until we get to the ending day after or on the end of the month.
        while (this.dateAdapter.getDay(lastDay) !== weekEndsOn) {
            lastDay = this.dateAdapter.add(lastDay, { days: 1 });
        }
        // collect all the days to display.
        while (firstDay <= lastDay) {
            days.push(firstDay);
            firstDay = this.dateAdapter.add(firstDay, { days: 1 });
        }
        return days;
    });
    isSelected(date) {
        return this.date()?.some((d) => this.dateAdapter.isSameDay(d, date)) ?? false;
    }
    selectDate(date) {
        const selected = this.date();
        if (this.isSelected(date)) {
            const minSelection = this.minSelection();
            if (selected?.length === minSelection) {
                // min selection reached, do not allow to deselect
                return;
            }
            this.date.set(selected?.filter((d) => !this.dateAdapter.isSameDay(d, date)));
        }
        else {
            const maxSelection = this.maxSelection();
            if (selected?.length === maxSelection) {
                // max selection reached, reset the selection to date
                this.date.set([date]);
            }
            else {
                // add the date to the selection
                this.date.set([...(selected ?? []), date]);
            }
        }
    }
    // same as in brn-calendar.directive.ts
    /** @internal Constrain a date to the min and max boundaries */
    constrainDate(date) {
        const min = this.min();
        const max = this.max();
        // If there is no min or max, return the date.
        if (!min && !max) {
            return date;
        }
        // If there is a min and the date is before the min, return the min.
        if (min && this.dateAdapter.isBefore(date, this.dateAdapter.startOfDay(min))) {
            return min;
        }
        // If there is a max and the date is after the max, return the max.
        if (max && this.dateAdapter.isAfter(date, this.dateAdapter.endOfDay(max))) {
            return max;
        }
        // Return the date.
        return date;
    }
    /** @internal Determine if a date is disabled */
    isDateDisabled(date) {
        // if the calendar is disabled we can't select this date
        if (this.disabled()) {
            return true;
        }
        // if the date is outside the min and max range
        const min = this.min();
        const max = this.max();
        if (min && this.dateAdapter.isBefore(date, this.dateAdapter.startOfDay(min))) {
            return true;
        }
        if (max && this.dateAdapter.isAfter(date, this.dateAdapter.endOfDay(max))) {
            return true;
        }
        // if this specific date is disabled
        const disabledFn = this.dateDisabled();
        if (disabledFn(date)) {
            return true;
        }
        return false;
    }
    /** @internal Set the focused date */
    setFocusedDate(date) {
        // check if the date is disabled.
        if (this.isDateDisabled(date)) {
            return;
        }
        this.state().focusedDate.set(date);
        // wait until the cells have all updated
        afterNextRender({
            write: () => {
                // focus the cell with the target date.
                const cell = this.cells().find((c) => this.dateAdapter.isSameDay(c.date(), date));
                if (cell) {
                    cell.focus();
                }
            },
        }, {
            injector: this._injector,
        });
        // we must update the view to ensure the focused cell is visible.
        this._changeDetector.detectChanges();
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarMultiDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.8", type: BrnCalendarMultiDirective, isStandalone: true, selector: "[brnCalendarMulti]", inputs: { min: { classPropertyName: "min", publicName: "min", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "max", isSignal: true, isRequired: false, transformFunction: null }, minSelection: { classPropertyName: "minSelection", publicName: "minSelection", isSignal: true, isRequired: false, transformFunction: null }, maxSelection: { classPropertyName: "maxSelection", publicName: "maxSelection", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, date: { classPropertyName: "date", publicName: "date", isSignal: true, isRequired: false, transformFunction: null }, dateDisabled: { classPropertyName: "dateDisabled", publicName: "dateDisabled", isSignal: true, isRequired: false, transformFunction: null }, weekStartsOn: { classPropertyName: "weekStartsOn", publicName: "weekStartsOn", isSignal: true, isRequired: false, transformFunction: null }, defaultFocusedDate: { classPropertyName: "defaultFocusedDate", publicName: "defaultFocusedDate", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { date: "dateChange" }, providers: [provideBrnCalendar(BrnCalendarMultiDirective)], queries: [{ propertyName: "header", first: true, predicate: BrnCalendarHeaderDirective, descendants: true, isSignal: true }, { propertyName: "cells", predicate: BrnCalendarCellButtonDirective, descendants: true, isSignal: true }], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarMultiDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnCalendarMulti]',
                    standalone: true,
                    providers: [provideBrnCalendar(BrnCalendarMultiDirective)],
                }]
        }] });

const BrnCalendarImports = [
    BrnCalendarCellButtonDirective,
    BrnCalendarGridDirective,
    BrnCalendarHeaderDirective,
    BrnCalendarNextButtonDirective,
    BrnCalendarPreviousButtonDirective,
    BrnCalendarWeekDirective,
    BrnCalendarWeekdayDirective,
    BrnCalendarDirective,
    BrnCalendarCellDirective,
    BrnCalendarMultiDirective,
];
class BrnCalendarModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarModule, imports: [BrnCalendarCellButtonDirective,
            BrnCalendarGridDirective,
            BrnCalendarHeaderDirective,
            BrnCalendarNextButtonDirective,
            BrnCalendarPreviousButtonDirective,
            BrnCalendarWeekDirective,
            BrnCalendarWeekdayDirective,
            BrnCalendarDirective,
            BrnCalendarCellDirective,
            BrnCalendarMultiDirective], exports: [BrnCalendarCellButtonDirective,
            BrnCalendarGridDirective,
            BrnCalendarHeaderDirective,
            BrnCalendarNextButtonDirective,
            BrnCalendarPreviousButtonDirective,
            BrnCalendarWeekDirective,
            BrnCalendarWeekdayDirective,
            BrnCalendarDirective,
            BrnCalendarCellDirective,
            BrnCalendarMultiDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnCalendarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnCalendarImports],
                    exports: [...BrnCalendarImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnCalendarCellButtonDirective, BrnCalendarCellDirective, BrnCalendarDirective, BrnCalendarGridDirective, BrnCalendarHeaderDirective, BrnCalendarI18nToken, BrnCalendarImports, BrnCalendarModule, BrnCalendarMultiDirective, BrnCalendarNextButtonDirective, BrnCalendarPreviousButtonDirective, BrnCalendarToken, BrnCalendarWeekDirective, BrnCalendarWeekdayDirective, injectBrnCalendar, injectBrnCalendarI18n, provideBrnCalendar, provideBrnCalendarI18n };
//# sourceMappingURL=spartan-ng-brain-calendar.mjs.map
