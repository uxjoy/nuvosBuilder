import * as i0 from '@angular/core';
import { signal, computed, HostListener, Directive, contentChild, ViewEncapsulation, ChangeDetectionStrategy, Component, inject, ElementRef, input, booleanAttribute, Pipe, NgModule } from '@angular/core';

class BrnAvatarImageDirective {
    _loaded = signal(false);
    onError() {
        this._loaded.set(false);
    }
    onLoad() {
        this._loaded.set(true);
    }
    canShow = computed(() => this._loaded());
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAvatarImageDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.8", type: BrnAvatarImageDirective, isStandalone: true, selector: "img[brnAvatarImage]", host: { listeners: { "error": "onError()", "load": "onLoad()" } }, exportAs: ["avatarImage"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAvatarImageDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'img[brnAvatarImage]',
                    standalone: true,
                    exportAs: 'avatarImage',
                }]
        }], propDecorators: { onError: [{
                type: HostListener,
                args: ['error']
            }], onLoad: [{
                type: HostListener,
                args: ['load']
            }] } });

class BrnAvatarComponent {
    image = contentChild(BrnAvatarImageDirective);
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAvatarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
    /** @nocollapse */ static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.8", type: BrnAvatarComponent, isStandalone: true, selector: "brn-avatar", queries: [{ propertyName: "image", first: true, predicate: BrnAvatarImageDirective, descendants: true, isSignal: true }], ngImport: i0, template: `
		@if (image()?.canShow()) {
			<ng-content select="[brnAvatarImage]" />
		} @else {
			<ng-content select="[brnAvatarFallback]" />
		}
	`, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAvatarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'brn-avatar',
                    standalone: true,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    template: `
		@if (image()?.canShow()) {
			<ng-content select="[brnAvatarImage]" />
		} @else {
			<ng-content select="[brnAvatarFallback]" />
		}
	`,
                }]
        }] });

class BrnAvatarFallbackDirective {
    _element = inject(ElementRef).nativeElement;
    userClass = input('', { alias: 'class' });
    autoColor = input(false, { transform: booleanAttribute });
    getTextContent() {
        return this._element.textContent;
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAvatarFallbackDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
    /** @nocollapse */ static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.8", type: BrnAvatarFallbackDirective, isStandalone: true, selector: "[brnAvatarFallback]", inputs: { userClass: { classPropertyName: "userClass", publicName: "class", isSignal: true, isRequired: false, transformFunction: null }, autoColor: { classPropertyName: "autoColor", publicName: "autoColor", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["avatarFallback"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAvatarFallbackDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[brnAvatarFallback]',
                    standalone: true,
                    exportAs: 'avatarFallback',
                }]
        }] });

function hashString(str) {
    let h;
    for (let i = 0; i < str.length; i++)
        h = (Math.imul(31, h || 0) + str.charCodeAt(i)) | 0;
    return h || 0;
}
function hashManyTimes(times, str) {
    let h = hashString(str);
    for (let i = 0; i < times; i++)
        h = hashString(String(h));
    return h;
}
function hexColorFor(str) {
    const hash = str.length <= 2 ? hashManyTimes(5, str) : hashString(str);
    let color = '#';
    for (let i = 0; i < 3; i += 1) {
        const value = (hash >> (i * 8)) & 0xff;
        color += `00${value.toString(16)}`.slice(-2);
    }
    return color;
}

const toInitial = (capitalize = true) => (word) => {
    const initial = word.charAt(0);
    return capitalize ? initial.toLocaleUpperCase() : initial;
};
const firstAndLast = (initials) => `${initials[0]}${initials[initials.length - 1]}`;
class InitialsPipe {
    transform(name, capitalize = true, firstAndLastOnly = true, delimiter = ' ') {
        if (!name)
            return '';
        const initials = name.trim().split(delimiter).filter(Boolean).map(toInitial(capitalize));
        if (firstAndLastOnly && initials.length > 1)
            return firstAndLast(initials);
        return initials.join('');
    }
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: InitialsPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
    /** @nocollapse */ static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: InitialsPipe, isStandalone: true, name: "initials" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: InitialsPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'initials',
                    standalone: true,
                }]
        }] });

const isShortHand = (hex) => hex.length === 3;
const cleanup = (hex) => {
    const noHash = hex.replace('#', '').trim().toLowerCase();
    if (!isShortHand(noHash))
        return noHash;
    return noHash
        .split('')
        .map((char) => char + char)
        .join('');
};
const isBright = (hex) => Number.parseInt(cleanup(hex), 16) > 0xffffff / 1.25;

const BrnAvatarImports = [BrnAvatarComponent, BrnAvatarFallbackDirective, BrnAvatarImageDirective];
class BrnAvatarModule {
    /** @nocollapse */ static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAvatarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.8", ngImport: i0, type: BrnAvatarModule, imports: [BrnAvatarComponent, BrnAvatarFallbackDirective, BrnAvatarImageDirective], exports: [BrnAvatarComponent, BrnAvatarFallbackDirective, BrnAvatarImageDirective] });
    /** @nocollapse */ static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAvatarModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.8", ngImport: i0, type: BrnAvatarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...BrnAvatarImports],
                    exports: [...BrnAvatarImports],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BrnAvatarComponent, BrnAvatarFallbackDirective, BrnAvatarImageDirective, BrnAvatarImports, BrnAvatarModule, InitialsPipe, hexColorFor, isBright };
//# sourceMappingURL=spartan-ng-brain-avatar.mjs.map
