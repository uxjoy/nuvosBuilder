{
  "version": 3,
  "sources": ["../../../../../../node_modules/@angular/cdk/fesm2022/typeahead-9ZW4Dtsf.mjs", "../../../../../../node_modules/@angular/cdk/fesm2022/list-key-manager-CyOIXo8P.mjs", "../../../../../../node_modules/@angular/cdk/fesm2022/focus-key-manager-C1rAQJ5z.mjs"],
  "sourcesContent": ["import { Subject } from 'rxjs';\nimport { tap, debounceTime, filter, map } from 'rxjs/operators';\nimport { A, Z, b as ZERO, N as NINE } from './keycodes-CpHkExLC.mjs';\nconst DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS = 200;\n/**\n * Selects items based on keyboard inputs. Implements the typeahead functionality of\n * `role=\"listbox\"` or `role=\"tree\"` and other related roles.\n */\nclass Typeahead {\n  _letterKeyStream = new Subject();\n  _items = [];\n  _selectedItemIndex = -1;\n  /** Buffer for the letters that the user has pressed */\n  _pressedLetters = [];\n  _skipPredicateFn;\n  _selectedItem = new Subject();\n  selectedItem = this._selectedItem;\n  constructor(initialItems, config) {\n    const typeAheadInterval = typeof config?.debounceInterval === 'number' ? config.debounceInterval : DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS;\n    if (config?.skipPredicate) {\n      this._skipPredicateFn = config.skipPredicate;\n    }\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && initialItems.length && initialItems.some(item => typeof item.getLabel !== 'function')) {\n      throw new Error('KeyManager items in typeahead mode must implement the `getLabel` method.');\n    }\n    this.setItems(initialItems);\n    this._setupKeyHandler(typeAheadInterval);\n  }\n  destroy() {\n    this._pressedLetters = [];\n    this._letterKeyStream.complete();\n    this._selectedItem.complete();\n  }\n  setCurrentSelectedItemIndex(index) {\n    this._selectedItemIndex = index;\n  }\n  setItems(items) {\n    this._items = items;\n  }\n  handleKey(event) {\n    const keyCode = event.keyCode;\n    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n    // otherwise fall back to resolving alphanumeric characters via the keyCode.\n    if (event.key && event.key.length === 1) {\n      this._letterKeyStream.next(event.key.toLocaleUpperCase());\n    } else if (keyCode >= A && keyCode <= Z || keyCode >= ZERO && keyCode <= NINE) {\n      this._letterKeyStream.next(String.fromCharCode(keyCode));\n    }\n  }\n  /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n  isTyping() {\n    return this._pressedLetters.length > 0;\n  }\n  /** Resets the currently stored sequence of typed letters. */\n  reset() {\n    this._pressedLetters = [];\n  }\n  _setupKeyHandler(typeAheadInterval) {\n    // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n    // and convert those letters back into a string. Afterwards find the first item that starts\n    // with that string and select it.\n    this._letterKeyStream.pipe(tap(letter => this._pressedLetters.push(letter)), debounceTime(typeAheadInterval), filter(() => this._pressedLetters.length > 0), map(() => this._pressedLetters.join('').toLocaleUpperCase())).subscribe(inputString => {\n      // Start at 1 because we want to start searching at the item immediately\n      // following the current active item.\n      for (let i = 1; i < this._items.length + 1; i++) {\n        const index = (this._selectedItemIndex + i) % this._items.length;\n        const item = this._items[index];\n        if (!this._skipPredicateFn?.(item) && item.getLabel?.().toLocaleUpperCase().trim().indexOf(inputString) === 0) {\n          this._selectedItem.next(item);\n          break;\n        }\n      }\n      this._pressedLetters = [];\n    });\n  }\n}\nexport { Typeahead as T };\n", "import { signal, QueryList, isSignal, effect } from '@angular/core';\nimport { Subscription, Subject } from 'rxjs';\nimport { T as Typeahead } from './typeahead-9ZW4Dtsf.mjs';\nimport { hasModifierKey } from './keycodes.mjs';\nimport { P as PAGE_DOWN, a as PAGE_UP, E as END, H as HOME, L as LEFT_ARROW, R as RIGHT_ARROW, U as UP_ARROW, D as DOWN_ARROW, T as TAB } from './keycodes-CpHkExLC.mjs';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass ListKeyManager {\n  _items;\n  _activeItemIndex = -1;\n  _activeItem = signal(null);\n  _wrap = false;\n  _typeaheadSubscription = Subscription.EMPTY;\n  _itemChangesSubscription;\n  _vertical = true;\n  _horizontal;\n  _allowedModifierKeys = [];\n  _homeAndEnd = false;\n  _pageUpAndDown = {\n    enabled: false,\n    delta: 10\n  };\n  _effectRef;\n  _typeahead;\n  /**\n   * Predicate function that can be used to check whether an item should be skipped\n   * by the key manager. By default, disabled items are skipped.\n   */\n  _skipPredicateFn = item => item.disabled;\n  constructor(_items, injector) {\n    this._items = _items;\n    // We allow for the items to be an array because, in some cases, the consumer may\n    // not have access to a QueryList of the items they want to manage (e.g. when the\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (_items instanceof QueryList) {\n      this._itemChangesSubscription = _items.changes.subscribe(newItems => this._itemsChanged(newItems.toArray()));\n    } else if (isSignal(_items)) {\n      if (!injector && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw new Error('ListKeyManager constructed with a signal must receive an injector');\n      }\n      this._effectRef = effect(() => this._itemsChanged(_items()), {\n        injector\n      });\n    }\n  }\n  /**\n   * Stream that emits any time the TAB key is pressed, so components can react\n   * when focus is shifted off of the list.\n   */\n  tabOut = new Subject();\n  /** Stream that emits whenever the active item of the list manager changes. */\n  change = new Subject();\n  /**\n   * Sets the predicate function that determines which items should be skipped by the\n   * list key manager.\n   * @param predicate Function that determines whether the given item should be skipped.\n   */\n  skipPredicate(predicate) {\n    this._skipPredicateFn = predicate;\n    return this;\n  }\n  /**\n   * Configures wrapping mode, which determines whether the active item will wrap to\n   * the other end of list when there are no more items in the given direction.\n   * @param shouldWrap Whether the list should wrap when reaching the end.\n   */\n  withWrap(shouldWrap = true) {\n    this._wrap = shouldWrap;\n    return this;\n  }\n  /**\n   * Configures whether the key manager should be able to move the selection vertically.\n   * @param enabled Whether vertical selection should be enabled.\n   */\n  withVerticalOrientation(enabled = true) {\n    this._vertical = enabled;\n    return this;\n  }\n  /**\n   * Configures the key manager to move the selection horizontally.\n   * Passing in `null` will disable horizontal movement.\n   * @param direction Direction in which the selection can be moved.\n   */\n  withHorizontalOrientation(direction) {\n    this._horizontal = direction;\n    return this;\n  }\n  /**\n   * Modifier keys which are allowed to be held down and whose default actions will be prevented\n   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n   */\n  withAllowedModifierKeys(keys) {\n    this._allowedModifierKeys = keys;\n    return this;\n  }\n  /**\n   * Turns on typeahead mode which allows users to set the active item by typing.\n   * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n   */\n  withTypeAhead(debounceInterval = 200) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const items = this._getItemsArray();\n      if (items.length > 0 && items.some(item => typeof item.getLabel !== 'function')) {\n        throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n      }\n    }\n    this._typeaheadSubscription.unsubscribe();\n    const items = this._getItemsArray();\n    this._typeahead = new Typeahead(items, {\n      debounceInterval: typeof debounceInterval === 'number' ? debounceInterval : undefined,\n      skipPredicate: item => this._skipPredicateFn(item)\n    });\n    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(item => {\n      this.setActiveItem(item);\n    });\n    return this;\n  }\n  /** Cancels the current typeahead sequence. */\n  cancelTypeahead() {\n    this._typeahead?.reset();\n    return this;\n  }\n  /**\n   * Configures the key manager to activate the first and last items\n   * respectively when the Home or End key is pressed.\n   * @param enabled Whether pressing the Home or End key activates the first/last item.\n   */\n  withHomeAndEnd(enabled = true) {\n    this._homeAndEnd = enabled;\n    return this;\n  }\n  /**\n   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n   * respectively when the Page-Up or Page-Down key is pressed.\n   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n   * @param delta Whether pressing the Home or End key activates the first/last item.\n   */\n  withPageUpDown(enabled = true, delta = 10) {\n    this._pageUpAndDown = {\n      enabled,\n      delta\n    };\n    return this;\n  }\n  setActiveItem(item) {\n    const previousActiveItem = this._activeItem();\n    this.updateActiveItem(item);\n    if (this._activeItem() !== previousActiveItem) {\n      this.change.next(this._activeItemIndex);\n    }\n  }\n  /**\n   * Sets the active item depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event) {\n    const keyCode = event.keyCode;\n    const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n    const isModifierAllowed = modifiers.every(modifier => {\n      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n    });\n    switch (keyCode) {\n      case TAB:\n        this.tabOut.next();\n        return;\n      case DOWN_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n      case UP_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n      case RIGHT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n      case LEFT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n      case HOME:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setFirstItemActive();\n          break;\n        } else {\n          return;\n        }\n      case END:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setLastItemActive();\n          break;\n        } else {\n          return;\n        }\n      case PAGE_UP:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex - this._pageUpAndDown.delta;\n          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n          break;\n        } else {\n          return;\n        }\n      case PAGE_DOWN:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex + this._pageUpAndDown.delta;\n          const itemsLength = this._getItemsArray().length;\n          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n          break;\n        } else {\n          return;\n        }\n      default:\n        if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n          this._typeahead?.handleKey(event);\n        }\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n    this._typeahead?.reset();\n    event.preventDefault();\n  }\n  /** Index of the currently active item. */\n  get activeItemIndex() {\n    return this._activeItemIndex;\n  }\n  /** The active item. */\n  get activeItem() {\n    return this._activeItem();\n  }\n  /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n  isTyping() {\n    return !!this._typeahead && this._typeahead.isTyping();\n  }\n  /** Sets the active item to the first enabled item in the list. */\n  setFirstItemActive() {\n    this._setActiveItemByIndex(0, 1);\n  }\n  /** Sets the active item to the last enabled item in the list. */\n  setLastItemActive() {\n    this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);\n  }\n  /** Sets the active item to the next enabled item in the list. */\n  setNextItemActive() {\n    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n  /** Sets the active item to a previous enabled item in the list. */\n  setPreviousItemActive() {\n    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1);\n  }\n  updateActiveItem(item) {\n    const itemArray = this._getItemsArray();\n    const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n    const activeItem = itemArray[index];\n    // Explicitly check for `null` and `undefined` because other falsy values are valid.\n    this._activeItem.set(activeItem == null ? null : activeItem);\n    this._activeItemIndex = index;\n    this._typeahead?.setCurrentSelectedItemIndex(index);\n  }\n  /** Cleans up the key manager. */\n  destroy() {\n    this._typeaheadSubscription.unsubscribe();\n    this._itemChangesSubscription?.unsubscribe();\n    this._effectRef?.destroy();\n    this._typeahead?.destroy();\n    this.tabOut.complete();\n    this.change.complete();\n  }\n  /**\n   * This method sets the active item, given a list of items and the delta between the\n   * currently active item and the new active item. It will calculate differently\n   * depending on whether wrap mode is turned on.\n   */\n  _setActiveItemByDelta(delta) {\n    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n  }\n  /**\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n   * down the list until it finds an item that is not disabled, and it will wrap if it\n   * encounters either end of the list.\n   */\n  _setActiveInWrapMode(delta) {\n    const items = this._getItemsArray();\n    for (let i = 1; i <= items.length; i++) {\n      const index = (this._activeItemIndex + delta * i + items.length) % items.length;\n      const item = items[index];\n      if (!this._skipPredicateFn(item)) {\n        this.setActiveItem(index);\n        return;\n      }\n    }\n  }\n  /**\n   * Sets the active item properly given the default mode. In other words, it will\n   * continue to move down the list until it finds an item that is not disabled. If\n   * it encounters either end of the list, it will stop and not wrap.\n   */\n  _setActiveInDefaultMode(delta) {\n    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n  }\n  /**\n   * Sets the active item to the first enabled item starting at the index specified. If the\n   * item is disabled, it will move in the fallbackDelta direction until it either\n   * finds an enabled item or encounters the end of the list.\n   */\n  _setActiveItemByIndex(index, fallbackDelta) {\n    const items = this._getItemsArray();\n    if (!items[index]) {\n      return;\n    }\n    while (this._skipPredicateFn(items[index])) {\n      index += fallbackDelta;\n      if (!items[index]) {\n        return;\n      }\n    }\n    this.setActiveItem(index);\n  }\n  /** Returns the items as an array. */\n  _getItemsArray() {\n    if (isSignal(this._items)) {\n      return this._items();\n    }\n    return this._items instanceof QueryList ? this._items.toArray() : this._items;\n  }\n  /** Callback for when the items have changed. */\n  _itemsChanged(newItems) {\n    this._typeahead?.setItems(newItems);\n    const activeItem = this._activeItem();\n    if (activeItem) {\n      const newIndex = newItems.indexOf(activeItem);\n      if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n        this._activeItemIndex = newIndex;\n        this._typeahead?.setCurrentSelectedItemIndex(newIndex);\n      }\n    }\n  }\n}\nexport { ListKeyManager as L };\n", "import { L as ListKeyManager } from './list-key-manager-CyOIXo8P.mjs';\nclass FocusKeyManager extends ListKeyManager {\n  _origin = 'program';\n  /**\n   * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n   * @param origin Focus origin to be used when focusing items.\n   */\n  setFocusOrigin(origin) {\n    this._origin = origin;\n    return this;\n  }\n  setActiveItem(item) {\n    super.setActiveItem(item);\n    if (this.activeItem) {\n      this.activeItem.focus(this._origin);\n    }\n  }\n}\nexport { FocusKeyManager as F };\n"],
  "mappings": "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",
  "names": ["items"]
}
